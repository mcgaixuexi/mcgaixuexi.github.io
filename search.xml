<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>编程题</title>
    <url>/posts/879807/</url>
    <content><![CDATA[<!-- build time:Mon Mar 09 2020 17:05:46 GMT+0800 (GMT+08:00) --><h4 id="center-前端刷题每日汇总😄-center"><center>前端刷题每日汇总😄</center></h4><a id="more"></a><p>1.获取url中的参数</p><p>指定参数名称，返回该参数的值 或者 空字符串</p><p>不指定参数名称，返回全部的参数对象 或者 {}</p><p>如果存在多个同名参数，则返回数组</p><p>输入 <a href="http://www.nowcoder.com?key=1&amp;key=2&amp;key=3&amp;test=4#hehe" target="_blank" rel="noopener">http://www.nowcoder.com?key=1&amp;key=2&amp;key=3&amp;test=4#hehe</a></p><p>输出 [1,2,3]</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUrlParam</span>(<span class="params">sUrl, sKey</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">          <span class="keyword">var</span> index = sUrl.indexOf(<span class="string">'?'</span>);</span><br><span class="line">          <span class="comment">//url没有带参数</span></span><br><span class="line">          <span class="keyword">if</span>(index == <span class="number">-1</span>) &#123;</span><br><span class="line">              <span class="keyword">if</span>(sKey==<span class="literal">undefined</span>) &#123;</span><br><span class="line">                  <span class="keyword">return</span> obj;</span><br><span class="line">              &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                  <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">var</span> queryString = (sUrl.split(<span class="string">'?'</span>)[<span class="number">1</span>]).split(<span class="string">"#"</span>)[<span class="number">0</span>];</span><br><span class="line">          <span class="keyword">var</span> query = queryString.split(<span class="string">'&amp;'</span>);<span class="comment">//分离出所有参数</span></span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;query.length;i++) &#123;</span><br><span class="line">              <span class="keyword">var</span> keyValue = query[i].split(<span class="string">"="</span>);</span><br><span class="line">              <span class="keyword">var</span> key = keyValue[<span class="number">0</span>];</span><br><span class="line">              <span class="keyword">var</span> value = keyValue[<span class="number">1</span>];</span><br><span class="line">              <span class="keyword">if</span>(value == <span class="string">""</span>)&#123;</span><br><span class="line">                  <span class="keyword">continue</span>;<span class="comment">//value值为空，进行下一次循环</span></span><br><span class="line">              &#125;</span><br><span class="line">              <span class="comment">// hasOwnProperty()函数用于指示一个对象自身(不包括原型链)是否具有指定名称的属性。如果有，返回true，否则返回false</span></span><br><span class="line">              <span class="keyword">if</span>(obj.hasOwnProperty(key)) &#123;</span><br><span class="line">                  <span class="keyword">if</span>(<span class="built_in">Array</span>.isArray(obj[key])) &#123;<span class="comment">//判断是不是数组</span></span><br><span class="line">                      obj[key].push(value);</span><br><span class="line">                  &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                      <span class="keyword">var</span> val = obj[key];</span><br><span class="line">                      obj[key] = [];</span><br><span class="line">                      obj[key].push(val);</span><br><span class="line">                      obj[key].push(value);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;<span class="comment">//有新参数，直接添加</span></span><br><span class="line">                  obj[key]=value;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//指定参数名</span></span><br><span class="line">          <span class="keyword">if</span>(sKey) &#123;</span><br><span class="line">              <span class="keyword">return</span> obj[sKey]?obj[sKey]:<span class="string">""</span>;</span><br><span class="line">          &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="keyword">return</span> obj;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p>另外一种方式就是用正则表达式</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUrlParam2</span>(<span class="params">sUrl, sKey</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> resObj = &#123;&#125;;</span><br><span class="line">            <span class="keyword">var</span> reg = <span class="regexp">/(\w+)=(\w+)/g</span>;</span><br><span class="line">            <span class="keyword">while</span> (reg.exec(sUrl)) &#123;</span><br><span class="line">                resObj[<span class="built_in">RegExp</span>.$<span class="number">1</span>] ? resObj[<span class="built_in">RegExp</span>.$<span class="number">1</span>] = [].concat(resObj[<span class="built_in">RegExp</span>.$<span class="number">1</span>], <span class="built_in">RegExp</span>.$<span class="number">2</span>) : resObj[<span class="built_in">RegExp</span>.$<span class="number">1</span>] = <span class="built_in">RegExp</span>.$<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sKey) &#123;</span><br><span class="line">                <span class="keyword">return</span> (resObj[sKey] ? resObj[sKey] : <span class="string">''</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> resObj;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>2.查找两个节点的最近一个共同父节点，可以包括节点本身</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commonParentNode</span>(<span class="params">oNode1, oNode2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (oNode1) &#123;</span><br><span class="line">        <span class="keyword">if</span> (oNode1.contains(oNode2)) &#123;</span><br><span class="line">            <span class="keyword">return</span> oNode1;</span><br><span class="line">        &#125;</span><br><span class="line">        oNode1 = oNode1.parentNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> oNode1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.根据包名，在指定空间中创建对象</p><p>输入描述:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">namespace(&#123;<span class="attr">a</span>: &#123;<span class="attr">test</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>&#125;&#125;, <span class="string">'a.b.c.d'</span>)</span><br></pre></td></tr></table></figure><p>输出描述:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">a</span>: &#123;<span class="attr">test</span>: <span class="number">1</span>, <span class="attr">b</span>: &#123;<span class="attr">c</span>: &#123;<span class="attr">d</span>: &#123;&#125;&#125;&#125;&#125;&#125;</span><br></pre></td></tr></table></figure><p>题目分析</p><p>用.分割字符串，取出包名；</p><p>保留对原始对象的引用：把原对象：{a: {test: 1, b: 2}} 浅拷贝给 一个新的对象newName。</p><p>用hasOwnProperty方法判断空间名是否在对象中；</p><p>若不在建立此空间名属性，赋值为空；</p><p>将指针指向下一个空间名属性。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">namesapce</span>(<span class="params">oNamespace, sPackage</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> package = sPackage.split(<span class="string">'.'</span>);</span><br><span class="line">    <span class="keyword">var</span> newName = oNamespace;<span class="comment">//保留对原对象的引用</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; package.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!newName.hasOwnProperty(package[i])) &#123; <span class="comment">// 空间名不在对象中，建立此空间名属性，赋值为空</span></span><br><span class="line">            newName[package[i]] = &#123;&#125;;</span><br><span class="line">            newName = newName[package[i]];<span class="comment">//将指针指向下一个空间名属性</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> oNamespace;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.为Array对象添加一个去除重复项的方法</p><p>输入</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[<span class="literal">false</span>, <span class="literal">true</span>, <span class="literal">undefined</span>, <span class="literal">null</span>, <span class="literal">NaN</span>, <span class="number">0</span>, <span class="number">1</span>, &#123;&#125;, &#123;&#125;, <span class="string">'a'</span>, <span class="string">'a'</span>, <span class="literal">NaN</span>]</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[<span class="literal">false</span>, <span class="literal">true</span>, <span class="literal">undefined</span>, <span class="literal">null</span>, <span class="literal">NaN</span>, <span class="number">0</span>, <span class="number">1</span>, &#123;&#125;, &#123;&#125;, <span class="string">'a'</span>]</span><br></pre></td></tr></table></figure><p>首先： {}和{}是不相等的，NaN和NaN是不相等的，而示例中是排除了多个NaN，</p><p>只剩下一个，而{}可以保留多个，所以通过flag和typeof双重关卡来控制</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.uniq = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> resArr = [];</span><br><span class="line">    <span class="keyword">var</span> flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (resArr.indexOf(<span class="keyword">this</span>[i]) == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>[i] != <span class="keyword">this</span>[i] &amp;&amp; <span class="keyword">typeof</span> (<span class="keyword">this</span>[i] === <span class="string">'number'</span>)) &#123; <span class="comment">//排除NaN</span></span><br><span class="line">                <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                    resArr.push(<span class="keyword">this</span>[i]);</span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                resArr.push(<span class="keyword">this</span>[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resArr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5.用 JavaScript 实现斐波那契数列函数,返回第n个斐波那契数。</p><p>如f(1) = 1, f(2) = 1 等</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fibonacci</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> fib = [];</span><br><span class="line">    fib[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    fib[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">3</span>;i&lt;=n;i++) &#123;</span><br><span class="line">        fib[i] = fib[i<span class="number">-1</span>]+fib[i<span class="number">-2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">return</span> fib[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6.两数相加</p><p>给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。</p><p>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</p><p>您可以假设除了数字 0 之外，这两个数都不会以 0 开头</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</span><br><span class="line">输出：7 -&gt; 0 -&gt; 8</span><br><span class="line">原因：342 + 465 &#x3D; 807</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.next = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">ListNode</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">        <span class="keyword">this</span>.next = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">l1</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">l2</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;ListNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> addTwoNumbers = <span class="function"><span class="keyword">function</span>(<span class="params">l1, l2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> c1 = l1,c2 = l2,l3,c3,carry =<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (c1 || c2 || carry) &#123;</span><br><span class="line">        <span class="keyword">var</span> v1=<span class="number">0</span>,v2=<span class="number">0</span>,sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(c1) &#123;</span><br><span class="line">            v1 = c1.val;</span><br><span class="line">            c1 = c1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(c2) &#123;</span><br><span class="line">            v2 = c2.val;</span><br><span class="line">            c2 = c2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        sum = v1 + v2 + carry;</span><br><span class="line">        carry = <span class="built_in">Math</span>.floor(sum / <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!c3) &#123;</span><br><span class="line">            l3 = <span class="keyword">new</span> ListNode(sum % <span class="number">10</span>);</span><br><span class="line">            c3 = l3;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            c3.next = <span class="keyword">new</span> ListNode(sum % <span class="number">10</span>);</span><br><span class="line">            c3 = c3.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l3;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>7.无重复字符的最长子串</p><p>给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。</p><p>示例 1:</p><p>输入: “abcabcbb”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。<br>示例 2:</p><p>输入: “bbbbb”<br>输出: 1<br>解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。<br>示例 3:</p><p>输入: “pwwkew”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。<br>请注意，你的答案必须是 子串 的长度，“pwke” 是一个子序列，不是子串。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">s</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// newStr.indexOf(s[i]) == -1</span></span><br><span class="line"><span class="keyword">var</span> lengthOfLongestSubstring = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">var</span> str = <span class="string">''</span>;</span><br><span class="line">   <span class="keyword">var</span> len = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;s.length;i++)&#123;</span><br><span class="line">		<span class="keyword">var</span> char = s.charAt(i);</span><br><span class="line">		<span class="keyword">var</span> index = str.indexOf(char);</span><br><span class="line">		<span class="keyword">if</span>(index === <span class="number">-1</span>)&#123;  <span class="comment">//遍历s将元素挨个放入到str中，每放入一次判断str中是否有重复项</span></span><br><span class="line">		str += char;</span><br><span class="line">		len = len&lt;str.length?str.length:len;<span class="comment">//记录最大长度项,每次重新记录str进行判断，是否大于上次一次最大项</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			str = str.substr(index + <span class="number">1</span>) + char; <span class="comment">//从当前重复项开始重新记录str</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	 <span class="keyword">return</span> len;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Js数据结构算法</title>
    <url>/posts/95b5f15a/</url>
    <content><![CDATA[<!-- build time:Mon Mar 09 2020 17:05:46 GMT+0800 (GMT+08:00) --><h4 id="center-今天学习的是数据结构与算法中的栈🙂-center"><center>今天学习的是数据结构与算法中的栈🙂</center></h4><a id="more"></a><h4 id="栈的简介">栈的简介</h4><p>栈是什么？栈是一个后进先出（LIFO）的数据结构。栈有啥作用？栈可以模拟算法或生活中的一些后进先出的场景，比如：</p><ul><li>十进制转二进制，你需要将余数倒序输出。</li><li>二叉树的先中后序非递归遍历都用到了栈。</li><li>在生活中，栈可以模拟煤炉与蜂窝煤等场景。</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">   <span class="comment">//封装栈类</span></span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">Stack</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 栈中的属性</span></span><br><span class="line">    <span class="keyword">this</span>.items = []</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 栈的相关操作</span></span><br><span class="line">    <span class="comment">// push(element):添加一个新元素到栈顶位置、</span></span><br><span class="line">    <span class="comment">// pop():移除栈顶的元素，同时返回被移除的元素</span></span><br><span class="line">    <span class="comment">// peek():返回栈顶的元素，不对栈做任何修改(这个方法不会移除栈顶的元素，仅仅返回它)</span></span><br><span class="line">    <span class="comment">// isEmpty():如果栈里没有任何元素就返回true，否则返回false</span></span><br><span class="line">    <span class="comment">// size():返回栈里的元素个数，这个方法和数组的length属性很类似</span></span><br><span class="line">    <span class="comment">// toString():将栈结构的内容以字符形式返回</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.将元素压入栈</span></span><br><span class="line">    Stack.prototype.push = <span class="function"><span class="keyword">function</span> (<span class="params">element</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.items.push(element)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2.从栈中取出元素</span></span><br><span class="line">    Stack.prototype.pop = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.items.pop()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.查看一下栈顶元素</span></span><br><span class="line">    Stack.prototype.peek = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.items[<span class="keyword">this</span>.items.length - <span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4.判断栈是否为空</span></span><br><span class="line">    Stack.prototype.isEmpty = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.items.length == <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 5.获取栈中元素的个数</span></span><br><span class="line">    Stack.prototype.size = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.items.length</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 6.toString方法</span></span><br><span class="line">    Stack.prototype.toString = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 20 10 12 8 7</span></span><br><span class="line">        <span class="keyword">var</span> resultString = <span class="string">''</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i&lt;<span class="keyword">this</span>.items.length; i++) &#123;</span><br><span class="line">            resultString += <span class="keyword">this</span>.items[i] + <span class="string">' '</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resultString</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>JavaScript数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>前端面试总结上篇</title>
    <url>/posts/13af804e/</url>
    <content><![CDATA[<!-- build time:Mon Mar 09 2020 17:05:46 GMT+0800 (GMT+08:00) --><h4 id="center-前端面试知识点🙂-center"><center>前端面试知识点🙂</center></h4><a id="more"></a><h2 id="CSS">CSS</h2><h3 id="1-盒模型">1. 盒模型</h3><p>页面渲染时，dom 元素所采用的 <strong>布局模型</strong>。可通过<code>box-sizing</code>进行设置。根据计算宽高的区域可分为：</p><ul><li><code>content-box</code> (W3C 标准盒模型)</li><li><code>border-box</code> (IE 盒模型)</li><li><code>padding-box</code></li><li><code>margin-box</code> (浏览器未实现)</li></ul><h3 id="2-BFC">2. BFC</h3><p><strong>块级格式化上下文</strong>，是一个独立的渲染区域，让处于 BFC 内部的元素与外部的元素相互隔离，使内外元素的定位不会相互影响。</p><blockquote><p>IE下为 Layout，可通过 zoom:1 触发</p></blockquote><ul><li>触发条件:<ul><li>根元素</li><li><code>position: absolute/fixed</code></li><li><code>display: inline-block / table</code></li><li><code>float</code> 元素</li><li><code>ovevflow</code> !== <code>visible</code></li></ul></li><li>规则:<ul><li>属于同一个 BFC 的两个相邻 Box 垂直排列</li><li>属于同一个 BFC 的两个相邻 Box 的 margin 会发生重叠</li><li>BFC 中子元素的 margin box 的左边， 与包含块 (BFC) border box的左边相接触 (子元素 absolute 除外)</li><li>BFC 的区域不会与 float 的元素区域重叠</li><li>计算 BFC 的高度时，浮动子元素也参与计算</li><li>文字层不会被浮动层覆盖，环绕于周围</li></ul></li><li>应用:<ul><li>阻止<code>margin</code>重叠</li><li>可以包含浮动元素 —— 清除内部浮动(清除浮动的原理是两个<code>div</code>都位于同一个 BFC 区域之中)</li><li>自适应两栏布局</li><li>可以阻止元素被浮动元素覆盖</li></ul></li></ul><h3 id="3-层叠上下文">3.层叠上下文</h3><p>元素提升为一个比较特殊的图层，在三维空间中 <strong>(z轴)</strong> 高出普通元素一等。</p><ul><li>触发条件<ul><li>根层叠上下文(<code>html</code>)</li><li><code>position</code></li><li>css3属性<ul><li><code>flex</code></li><li><code>transform</code></li><li><code>opacity</code></li><li><code>filter</code></li><li><code>will-change</code></li><li><code>-webkit-overflow-scrolling</code></li></ul></li></ul></li><li>层叠等级：层叠上下文在z轴上的排序<ul><li>在同一层叠上下文中，层叠等级才有意义</li><li><code>z-index</code>的优先级最高</li></ul></li></ul><p><img src="2.png" alt=""></p><h3 id="4-居中布局">4. 居中布局</h3><ul><li>水平居中<ul><li>行内元素: <code>text-align: center</code></li><li>块级元素: <code>margin: 0 auto</code></li><li><code>absolute + transform</code></li><li><code>flex + justify-content: center</code></li></ul></li><li>垂直居中<ul><li><code>line-height: height</code></li><li><code>absolute + transform</code></li><li><code>flex + align-items: center</code></li><li><code>table</code></li></ul></li><li>水平垂直居中<ul><li><code>absolute + transform</code></li><li><code>flex + justify-content + align-items</code></li></ul></li></ul><h3 id="5-选择器优先级">5. 选择器优先级</h3><ul><li><code>!important</code> &gt; 行内样式 &gt; <code>#id</code> &gt; <code>.class</code> &gt; <code>tag</code> &gt; * &gt; 继承 &gt; 默认</li><li>选择器 <strong>从右往左</strong> 解析</li></ul><h3 id="6-去除浮动影响，防止父级高度塌陷">6.去除浮动影响，防止父级高度塌陷</h3><ul><li>通过增加尾元素清除浮动<ul><li><code>:after / &lt;br&gt; : clear: both</code></li></ul></li><li>创建父级 BFC</li><li>父级设置高度</li></ul><h3 id="7-link-与-import-的区别">7.link 与 @import 的区别</h3><ul><li><code>link</code>功能较多，可以定义 RSS，定义 Rel 等作用，而<code>@import</code>只能用于加载 css</li><li>当解析到<code>link</code>时，页面会同步加载所引的 css，而<code>@import</code>所引用的 css 会等到页面加载完才被加载</li><li><code>@import</code>需要 IE5 以上才能使用</li><li><code>link</code>可以使用 js 动态引入，<code>@import</code>不行</li></ul><h3 id="8-CSS预处理器-Sass-Less-Postcss">8. CSS预处理器(Sass/Less/Postcss)</h3><p>CSS预处理器的原理: 是将类 CSS 语言通过 <strong>Webpack 编译</strong> 转成浏览器可读的真正 CSS。在这层编译之上，便可以赋予 CSS 更多更强大的功能，常用功能:</p><ul><li>嵌套</li><li>变量</li><li>循环语句</li><li>条件语句</li><li>自动前缀</li><li>单位转换</li><li>mixin复用</li></ul><p>面试中一般不会重点考察该点，一般介绍下自己在实战项目中的经验即可~</p><h3 id="9-CSS动画">9.CSS动画</h3><ul><li><p><code>transition</code>: 过渡动画</p><ul><li><code>transition-property</code>: 属性</li><li><code>transition-duration</code>: 间隔</li><li><code>transition-timing-function</code>: 曲线</li><li><code>transition-delay</code>: 延迟</li><li>常用钩子: <code>transitionend</code></li></ul></li><li><p><code>animation / keyframes</code></p><ul><li><p><code>animation-name</code>: 动画名称，对应<code>@keyframes</code></p></li><li><p><code>animation-duration</code>: 间隔</p></li><li><p><code>animation-timing-function</code>: 曲线</p></li><li><p><code>animation-delay</code>: 延迟</p></li><li><p><code>animation-iteration-count</code></p><p>: 次数</p><ul><li><code>infinite</code>: 循环动画</li></ul></li><li><p><code>animation-direction</code></p><p>: 方向</p><ul><li><code>alternate</code>: 反向播放</li></ul></li><li><p><code>animation-fill-mode</code></p><p>: 静止模式</p><ul><li><code>forwards</code>: 停止时，保留最后一帧</li><li><code>backwards</code>: 停止时，回到第一帧</li><li><code>both</code>: 同时运用 <code>forwards / backwards</code></li></ul></li><li><p>常用钩子: <code>animationend</code></p></li></ul></li><li><p>动画属性: 尽量使用动画属性进行动画，能拥有较好的性能表现</p><ul><li><code>translate</code></li><li><code>scale</code></li><li><code>rotate</code></li><li><code>skew</code></li><li><code>opacity</code></li><li><code>color</code></li></ul></li></ul><h3 id="经验">经验</h3><p>通常，CSS 并不是重点的考察领域，但这其实是由于现在国内业界对 CSS 的专注不够导致的，真正精通并专注于 CSS 的团队和人才并不多。因此如果能在 CSS 领域有自己的见解和经验，反而会为相当的加分和脱颖而出。</p><h2 id="JavaScript">JavaScript</h2><h3 id="1-原型-构造函数-实例">1. 原型 / 构造函数 / 实例</h3><ul><li>原型<code>(prototype)</code>: 一个简单的对象，用于实现对象的 <strong>属性继承</strong>。可以简单的理解成对象的爹。在 Firefox 和 Chrome 中，每个<code>JavaScript</code>对象中都包含一个<code>__proto__</code> (非标准)的属性指向它爹(该对象的原型)，可<code>obj.__proto__</code>进行访问。</li><li>构造函数: 可以通过<code>new</code>来 <strong>新建一个对象</strong> 的函数。</li><li>实例: 通过构造函数和<code>new</code>创建出来的对象，便是实例。 <strong>实例通过__proto__指向原型，通过constructor指向构造函数</strong>。</li></ul><p>说了一大堆，大家可能有点懵逼，这里来举个栗子，以<code>Object</code>为例，我们常用的<code>Object</code>便是一个构造函数，因此我们可以通过它构建实例。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实例</span></span><br><span class="line"><span class="keyword">const</span> instance = <span class="keyword">new</span> <span class="built_in">Object</span>()</span><br></pre></td></tr></table></figure><p>则此时， <strong>实例为instance</strong>, <strong>构造函数为Object</strong>，我们知道，构造函数拥有一个<code>prototype</code>的属性指向原型，因此原型为:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 原型</span></span><br><span class="line"><span class="keyword">const</span> prototype = <span class="built_in">Object</span>.prototype</span><br></pre></td></tr></table></figure><p>这里我们可以来看出三者的关系:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">实例.__proto__ === 原型</span><br><span class="line"></span><br><span class="line">原型.constructor === 构造函数</span><br><span class="line"></span><br><span class="line">构造函数.prototype === 原型</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这条线其实是是基于原型进行获取的，可以理解成一条基于原型的映射线</span></span><br><span class="line"><span class="comment">// 例如: </span></span><br><span class="line"><span class="comment">// const o = new Object()</span></span><br><span class="line"><span class="comment">// o.constructor === Object   --&gt; true</span></span><br><span class="line"><span class="comment">// o.__proto__ = null;</span></span><br><span class="line"><span class="comment">// o.constructor === Object   --&gt; false</span></span><br><span class="line">实例.constructor === 构造函数</span><br></pre></td></tr></table></figure><p>放大来看，我画了张图供大家彻底理解:</p><p><img src="3.png" alt=""></p><h3 id="2-原型链：">2.原型链：</h3><p><strong>原型链是由原型对象组成</strong>，每个对象都有 <code>__proto__</code> 属性，指向了创建该对象的构造函数的原型，<code>__proto__</code> 将对象连接起来组成了原型链。是一个用来<strong>实现继承和共享属性</strong>的有限的对象链。</p><ul><li><strong>属性查找机制</strong>: 当查找对象的属性时，如果实例对象自身不存在该属性，则沿着原型链往上一级查找，找到时则输出，不存在时，则继续沿着原型链往上一级查找，直至最顶级的原型对象<code>Object.prototype</code>，如还是没找到，则输出<code>undefined</code>；</li><li><strong>属性修改机制</strong>: 只会修改实例对象本身的属性，如果不存在，则进行添加该属性，如果需要修改原型的属性时，则可以用: <code>b.prototype.x = 2</code>；但是这样会造成所有继承于该对象的实例的属性发生改变。</li></ul><h3 id="3-执行上下文-EC">3. 执行上下文(EC)</h3><p>执行上下文可以简单理解为一个对象:</p><ul><li>它包含三个部分:<ul><li>变量对象(VO)</li><li>作用域链(词法作用域)</li><li><code>this</code>指向</li></ul></li><li>它的类型:<ul><li>全局执行上下文</li><li>函数执行上下文</li><li><code>eval</code>执行上下文</li></ul></li><li>代码执行过程:<ul><li>创建 <strong>全局上下文</strong> (global EC)</li><li>全局执行上下文 (caller) 逐行 <strong>自上而下</strong> 执行。遇到函数时，<strong>函数执行上下文</strong> (callee) 被<code>push</code>到执行栈顶层</li><li>函数执行上下文被激活，成为 active EC, 开始执行函数中的代码，caller 被挂起</li><li>函数执行完后，callee 被<code>pop</code>移除出执行栈，控制权交还全局上下文 (caller)，继续执行</li></ul></li></ul><h3 id="2-变量对象">2.变量对象</h3><p>变量对象，是执行上下文中的一部分，可以抽象为一种 <strong>数据作用域</strong>，其实也可以理解为就是一个简单的对象，它存储着该执行上下文中的所有 <strong>变量和函数声明(不包含函数表达式)</strong>。</p><blockquote><p>活动对象 (AO): 当变量对象所处的上下文为 active EC 时，称为活动对象。</p></blockquote><h3 id="3-作用域">3. 作用域</h3><p>执行上下文中还包含作用域链。理解作用域之前，先介绍下作用域。作用域其实可理解为该上下文中声明的 <strong>变量和声明的作用范围</strong>。可分为 <strong>块级作用域</strong> 和 <strong>函数作用域</strong></p><p>特性:</p><ul><li><strong>声明提前</strong>: 一个声明在函数体内都是可见的, 函数优先于变量</li><li>非匿名自执行函数，函数变量为 <strong>只读</strong> 状态，无法修改</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="number">1</span>) &#125;;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    foo = <span class="number">10</span>  <span class="comment">// 由于foo在函数中只为可读，因此赋值无效</span></span><br><span class="line">    <span class="built_in">console</span>.log(foo)</span><br><span class="line">&#125;()) </span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果打印：  ƒ foo() &#123; foo = 10 ; console.log(foo) &#125;</span></span><br></pre></td></tr></table></figure><h3 id="4-作用域链">4.作用域链</h3><p>我们知道，我们可以在执行上下文中访问到父级甚至全局的变量，这便是作用域链的功劳。作用域链可以理解为一组对象列表，包含 <strong>父级和自身的变量对象</strong>，因此我们便能通过作用域链访问到父级里声明的变量或者函数。</p><ul><li>由两部分组成:<ul><li><code>[[scope]]</code>属性: 指向父级变量对象和作用域链，也就是包含了父级的<code>[[scope]]</code>和<code>AO</code></li><li>AO: 自身活动对象</li></ul></li></ul><p>如此 <code>[[scopr]]</code>包含<code>[[scope]]</code>，便自上而下形成一条 <strong>链式作用域</strong>。</p><h3 id="5-闭包">5. 闭包</h3><p>闭包属于一种特殊的作用域，称为 <strong>静态作用域</strong>。它的定义可以理解为: <strong>父函数被销毁</strong> 的情况下，返回出的子函数的<code>[[scope]]</code>中仍然保留着父级的单变量对象和作用域链，因此可以继续访问到父级的变量对象，这样的函数称为闭包。</p><ul><li>闭包会产生一个很经典的问题:<ul><li>多个子函数的<code>[[scope]]</code>都是同时指向父级，是完全共享的。因此当父级的变量对象被修改时，所有子函数都受到影响。</li></ul></li><li>解决:<ul><li>变量可以通过 <strong>函数参数的形式</strong> 传入，避免使用默认的<code>[[scope]]</code>向上查找</li><li>使用<code>setTimeout</code>包裹，通过第三个参数传入</li><li>使用 <strong>块级作用域</strong>，让变量成为自己上下文的属性，避免共享</li></ul></li></ul><h3 id="6-script-引入方式：">6. script 引入方式：</h3><ul><li>html 静态<code>&lt;script&gt;</code>引入</li><li>js 动态插入<code>&lt;script&gt;</code></li><li><code>&lt;script defer&gt;</code>: 延迟加载，元素解析完成后执行</li><li><code>&lt;script async&gt;</code>: 异步加载，但执行时会阻塞元素渲染</li></ul><h3 id="7-对象的拷贝">7. 对象的拷贝</h3><ul><li><p>浅拷贝: 以赋值的形式拷贝引用对象，仍指向同一个地址，<strong>修改时原对象也会受到影响</strong></p><ul><li><code>Object.assign</code></li><li>展开运算符(…)</li></ul></li><li><p>深拷贝: 完全拷贝一个新对象，<strong>修改时原对象不再受到任何影响</strong></p><ul><li><p><code>JSON.parse(JSON.stringify(obj))</code></p><p>: 性能最快</p><ul><li>具有循环引用的对象时，报错</li></ul></li></ul></li><li><p>当值为函数、<code>undefined</code>、或<code>symbol</code>时，无法拷贝</p><ul><li>递归进行逐一赋值</li></ul></li></ul><h3 id="8-new运算符的执行过程">8. new运算符的执行过程</h3><ul><li>新生成一个对象</li><li>链接到原型: <code>obj.__proto__ = Con.prototype</code></li><li>绑定this: <code>apply</code></li><li>返回新对象(如果构造函数有自己 retrun 时，则返回该值)</li></ul><h3 id="9-instanceof原理">9. instanceof原理</h3><p>能在实例的 <strong>原型对象链</strong> 中找到该构造函数的<code>prototype</code>属性所指向的 <strong>原型对象</strong>，就返回<code>true</code>。即:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// __proto__: 代表原型对象链</span></span><br><span class="line">instance.[__proto__...] === instance.constructor.prototype</span><br><span class="line"></span><br><span class="line"><span class="comment">// return true</span></span><br></pre></td></tr></table></figure><h3 id="10-代码的复用">10. 代码的复用</h3><p>当你发现任何代码开始写第二遍时，就要开始考虑如何复用。一般有以下的方式:</p><ul><li>函数封装</li><li>继承</li><li>复制<code>extend</code></li><li>混入<code>mixin</code></li><li>借用<code>apply/call</code></li></ul><h3 id="11-继承">11. 继承</h3><p>在 JS 中，继承通常指的便是 <strong>原型链继承</strong>，也就是通过指定原型，并可以通过原型链继承原型上的属性或者方法。</p><ul><li>最优化: <strong>圣杯模式</strong></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> inherit = (<span class="function"><span class="keyword">function</span>(<span class="params">c,p</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">c,p</span>)</span>&#123;</span><br><span class="line">		F.prototype = p.prototype;</span><br><span class="line">		c.prototype = <span class="keyword">new</span> F();</span><br><span class="line">		c.uber = p.prototype;</span><br><span class="line">		c.prototype.constructor = c;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><ul><li>使用 ES6 的语法糖 <code>class / extends</code></li></ul><h3 id="12-类型转换">12. 类型转换</h3><p>大家都知道 JS 中在使用运算符号或者对比符时，会自带隐式转换，规则如下:</p><ul><li>-、*、/、% ：一律转换成数值后计算</li><li>+：<ul><li>数字 + 字符串 = 字符串， 运算顺序是从左到右</li><li>数字 + 对象， 优先调用对象的<code>valueOf</code> -&gt; <code>toString</code></li><li>数字 + <code>boolean/null</code> -&gt; 数字</li><li>数字 + <code>undefined</code> -&gt; <code>NaN</code></li></ul></li><li><code>[1].toString() === '1'</code></li><li><code>{}.toString() === '[object object]'</code></li><li><code>NaN</code> !== <code>NaN</code> 、<code>+undefined 为 NaN</code></li></ul><h3 id="13-类型判断">13. 类型判断</h3><p>判断 Target 的类型，单单用 typeof 并无法完全满足，这其实并不是 bug，本质原因是 JS 的万物皆对象的理论。因此要真正完美判断时，我们需要区分对待:</p><ul><li>基本类型(<code>null</code>): 使用 <code>String(null)</code></li><li>基本类型(<code>string / number / boolean / undefined</code>) + <code>function</code>: 直接使用 <code>typeof</code>即可</li><li>其余引用类型(<code>Array / Date / RegExp Error</code>): 调用<code>toString</code>后根据<code>[object XXX]</code>进行判断</li></ul><p>很稳的判断封装:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> class2type = &#123;&#125;</span><br><span class="line"><span class="string">'Array Date RegExp Object Error'</span>.split(<span class="string">' '</span>).forEach(<span class="function"><span class="params">e</span> =&gt;</span> class2type[ <span class="string">'[object '</span> + e + <span class="string">']'</span> ] = e.toLowerCase()) </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">type</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj == <span class="literal">null</span>) <span class="keyword">return</span> <span class="built_in">String</span>(obj)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> obj === <span class="string">'object'</span> ? class2type[ <span class="built_in">Object</span>.prototype.toString.call(obj) ] || <span class="string">'object'</span> : <span class="keyword">typeof</span> obj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="14-模块">14. 模块</h3><p>模块化开发在现代开发中已是必不可少的一部分，它大大提高了项目的可维护、可拓展和可协作性。通常，我们 <strong>在浏览器中使用 ES6 的模块化支持，在 Node 中使用 commonjs 的模块化支持。</strong></p><ul><li>分类:<ul><li>es6: <code>import / export</code></li><li>commonjs: <code>require / module.exports / exports</code></li><li>amd: <code>require / defined</code></li></ul></li><li><code>require</code>与<code>import</code>的区别<ul><li><code>require</code>支持 <strong>动态导入</strong>，<code>import</code>不支持，正在提案 (babel 下可支持)</li><li><code>require</code>是 <strong>同步</strong> 导入，<code>import</code>属于 <strong>异步</strong> 导入</li><li><code>require</code>是 <strong>值拷贝</strong>，导出值变化不会影响导入值；<code>import</code>指向 <strong>内存地址</strong>，导入值会随导出值而变化</li></ul></li></ul><h3 id="15-防抖与节流">15. 防抖与节流</h3><p>防抖与节流函数是一种最常用的 <strong>高频触发优化方式</strong>，能对性能有较大的帮助。</p><ul><li><strong>防抖 (debounce)</strong>: 将多次高频操作优化为只在最后一次执行，通常使用的场景是：用户输入，只需再输入完成后做一次输入校验即可。</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, wait, immediate</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> args = <span class="built_in">arguments</span></span><br><span class="line">        <span class="keyword">let</span> context = <span class="keyword">this</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (immediate &amp;&amp; !timer) &#123;</span><br><span class="line">            fn.apply(context, args)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (timer) clearTimeout(timer)</span><br><span class="line">        timer = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            fn.apply(context, args)</span><br><span class="line">        &#125;, wait)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>节流(throttle)</strong>: 每隔一段时间后执行一次，也就是降低频率，将高频操作优化成低频操作，通常使用场景: 滚动条事件 或者 resize 事件，通常每隔 100~500 ms执行一次即可。</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, wait, immediate</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">let</span> callNow = immediate</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> context = <span class="keyword">this</span>,</span><br><span class="line">            args = <span class="built_in">arguments</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (callNow) &#123;</span><br><span class="line">            fn.apply(context, args)</span><br><span class="line">            callNow = <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!timer) &#123;</span><br><span class="line">            timer = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                fn.apply(context, args)</span><br><span class="line">                timer = <span class="literal">null</span></span><br><span class="line">            &#125;, wait)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="16-函数执行改变this">16. 函数执行改变this</h3><p>由于 JS 的设计原理: 在函数中，可以引用运行环境中的变量。因此就需要一个机制来让我们可以在函数体内部获取当前的运行环境，这便是<code>this</code>。</p><p>因此要明白 <code>this</code> 指向，其实就是要搞清楚 函数的运行环境，说人话就是，谁调用了函数。例如:</p><ul><li><code>obj.fn()</code>，便是 <code>obj</code> 调用了函数，既函数中的 <code>this === obj</code></li><li><code>fn()</code>，这里可以看成 <code>window.fn()</code>，因此 <code>this === window</code></li></ul><p>但这种机制并不完全能满足我们的业务需求，因此提供了三种方式可以手动修改 <code>this</code> 的指向:</p><ul><li><code>call: fn.call(target, 1, 2)</code></li><li><code>apply: fn.apply(target, [1, 2])</code></li><li><code>bind: fn.bind(target)(1,2)</code></li></ul><h3 id="17-ES6-ES7">17. ES6/ES7</h3><p>由于 Babel 的强大和普及，现在 ES6/ES7 基本上已经是现代化开发的必备了。通过新的语法糖，能让代码整体更为简洁和易读。</p><ul><li><p>声明</p><ul><li><code>let / const</code>: 块级作用域、不存在变量提升、暂时性死区、不允许重复声明</li><li><code>const</code>: 声明常量，无法修改</li></ul></li><li><p>解构赋值</p></li><li><p><code>class / extend</code>: 类声明与继承</p></li><li><p><code>Set / Map</code>: 新的数据结构</p></li><li><p>异步解决方案:</p><ul><li><code>Promise</code>的使用与实现</li><li><code>generator</code>:<ul><li><code>yield</code>: 暂停代码</li><li><code>next()</code>: 继续执行代码</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">helloWorld</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'hello'</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'world'</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'ending'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> generator = helloWorld();</span><br><span class="line"></span><br><span class="line">generator.next()  <span class="comment">// &#123; value: 'hello', done: false &#125;</span></span><br><span class="line"></span><br><span class="line">generator.next()  <span class="comment">// &#123; value: 'world', done: false &#125;</span></span><br><span class="line"></span><br><span class="line">generator.next()  <span class="comment">// &#123; value: 'ending', done: true &#125;</span></span><br><span class="line"></span><br><span class="line">generator.next()  <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure><ul><li><code>await / async</code>: 是<code>generator</code>的语法糖， babel中是基于<code>promise</code>实现。</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getUserByAsync</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="keyword">let</span> user = <span class="keyword">await</span> fetchUser();</span><br><span class="line">   <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> user = <span class="keyword">await</span> getUserByAsync()</span><br><span class="line"><span class="built_in">console</span>.log(user)</span><br></pre></td></tr></table></figure></li></ul><h3 id="18-AST">18. AST</h3><p><strong>抽象语法树 (Abstract Syntax Tree)</strong>，是将代码逐字母解析成 <strong>树状对象</strong> 的形式。这是语言之间的转换、代码语法检查，代码风格检查，代码格式化，代码高亮，代码错误提示，代码自动补全等等的基础。例如:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">square</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> n * n</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过解析转化成的<code>AST</code>如下图:</p><p><img src="4.png" alt=""></p><h3 id="19-babel编译原理">19. babel编译原理</h3><ul><li>babylon 将 ES6/ES7 代码解析成 AST</li><li>babel-traverse 对 AST 进行遍历转译，得到新的 AST</li><li>新 AST 通过 babel-generator 转换成 ES5</li></ul><h3 id="20-函数柯里化">20. 函数柯里化</h3><p>在一个函数中，首先填充几个参数，然后再返回一个新的函数的技术，称为函数的柯里化。通常可用于在不侵入函数的前提下，为函数 <strong>预置通用参数</strong>，供多次重复调用。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> add = <span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">y</span>) </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> x + y</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> add1 = add(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">add1(<span class="number">2</span>) === <span class="number">3</span></span><br><span class="line">add1(<span class="number">20</span>) === <span class="number">21</span></span><br></pre></td></tr></table></figure><h3 id="21-数组-array">21. 数组(array)</h3><ul><li><code>map</code>: 遍历数组，返回回调返回值组成的新数组</li><li><code>forEach</code>: 无法<code>break</code>，可以用<code>try/catch</code>中<code>throw new Error</code>来停止</li><li><code>filter</code>: 过滤</li><li><code>some</code>: 有一项返回<code>true</code>，则整体为<code>true</code></li><li><code>every</code>: 有一项返回<code>false</code>，则整体为<code>false</code></li><li><code>join</code>: 通过指定连接符生成字符串</li><li><code>push / pop</code>: 末尾推入和弹出，改变原数组， 返回推入/弹出项</li><li><code>unshift / shift</code>: 头部推入和弹出，改变原数组，返回操作项</li><li><code>sort(fn) / reverse</code>: 排序与反转，改变原数组</li><li><code>concat</code>: 连接数组，不影响原数组， 浅拷贝</li><li><code>slice(start, end)</code>: 返回截断后的新数组，不改变原数组</li><li><code>splice(start, number, value...)</code>: 返回删除元素组成的数组，value 为插入项，改变原数组</li><li><code>indexOf / lastIndexOf(value, fromIndex)</code>: 查找数组项，返回对应的下标</li><li><code>reduce / reduceRight(fn(prev, cur)， defaultPrev)</code>: 两两执行，prev 为上次化简函数的<code>return</code>值，cur 为当前值(从第二项开始)</li><li>数组乱序：</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>];</span><br><span class="line">arr.sort(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.random() - <span class="number">0.5</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>数组拆解: flat: [1,[2,3]] --&gt; [1, 2, 3]</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.flat = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.toString().split(<span class="string">','</span>).map(<span class="function"><span class="params">item</span> =&gt;</span> +item )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="浏览器">浏览器</h2><h3 id="1-跨标签页通讯">1. 跨标签页通讯</h3><p>不同标签页间的通讯，本质原理就是去运用一些可以 <strong>共享的中间介质</strong>，因此比较常用的有以下方法:</p><ul><li>通过父页面<code>window.open()</code>和子页面<code>postMessage</code><ul><li>异步下，通过 <code>window.open('about: blank')</code> 和 <code>tab.location.href = '*'</code></li></ul></li><li>设置同域下共享的<code>localStorage</code>与监听<code>window.onstorage</code><ul><li>重复写入相同的值无法触发</li><li>会受到浏览器隐身模式等的限制</li></ul></li><li>设置共享<code>cookie</code>与不断轮询脏检查(<code>setInterval</code>)</li><li>借助服务端或者中间层实现</li></ul><h3 id="2-浏览器架构">2. 浏览器架构</h3><ul><li>用户界面</li><li>主进程</li><li>内核<ul><li>渲染引擎</li><li>JS 引擎<ul><li>执行栈</li></ul></li><li>事件触发线程<ul><li>消息队列<ul><li>微任务</li><li>宏任务</li></ul></li></ul></li><li>网络异步线程</li><li>定时器线程</li></ul></li></ul><h3 id="3-浏览器下事件循环-Event-Loop">3. 浏览器下事件循环(Event Loop)</h3><p>事件循环是指: 执行一个宏任务，然后执行清空微任务列表，循环再执行宏任务，再清微任务列表</p><ul><li>微任务 <code>microtask(jobs)</code>: <code>promise / ajax / Object.observe(该方法已废弃)</code></li><li>宏任务 <code>macrotask(task)</code>: <code>setTimout / script / IO / UI Rendering</code></li></ul><h3 id="4-从输入-url-到展示的过程">4. 从输入 url 到展示的过程</h3><ul><li>DNS 解析</li><li>TCP 三次握手</li><li>发送请求，分析 url，设置请求报文(头，主体)</li><li>服务器返回请求的文件 (html)</li><li>浏览器渲染<ul><li>HTML parser --&gt; DOM Tree<ul><li>标记化算法，进行元素状态的标记</li><li>dom 树构建</li></ul></li><li>CSS parser --&gt; Style Tree<ul><li>解析 css 代码，生成样式树</li></ul></li><li>attachment --&gt; Render Tree<ul><li>结合 dom树 与 style树，生成渲染树</li></ul></li><li>layout: 布局</li><li>GPU painting: 像素绘制页面</li></ul></li></ul><h3 id="5-重绘与回流">5. 重绘与回流</h3><p>当元素的样式发生变化时，浏览器需要触发更新，重新绘制元素。这个过程中，有两种类型的操作，即重绘与回流。</p><ul><li><strong>重绘(repaint)</strong>: 当元素样式的改变不影响布局时，浏览器将使用重绘对元素进行更新，此时由于只需要UI层面的重新像素绘制，因此 <strong>损耗较少</strong></li><li><strong>回流(reflow)</strong>: 当元素的尺寸、结构或触发某些属性时，浏览器会重新渲染页面，称为回流。此时，浏览器需要重新经过计算，计算后还需要重新页面布局，因此是较重的操作。会触发回流的操作:<ul><li>页面初次渲染</li><li>浏览器窗口大小改变</li><li>元素尺寸、位置、内容发生改变</li><li>元素字体大小变化</li><li>添加或者删除可见的 dom 元素</li><li>激活 CSS 伪类（例如：:hover）</li><li>查询某些属性或调用某些方法<ul><li>clientWidth、clientHeight、clientTop、clientLeft</li><li>offsetWidth、offsetHeight、offsetTop、offsetLeft</li><li>scrollWidth、scrollHeight、scrollTop、scrollLeft</li><li>getComputedStyle()</li><li>getBoundingClientRect()</li><li>scrollTo()</li></ul></li></ul></li></ul><p><strong>回流必定触发重绘，重绘不一定触发回流。重绘的开销较小，回流的代价较高。</strong></p><h4 id="最佳实践">最佳实践:</h4><ul><li>css<ul><li>避免使用<code>table</code>布局</li><li>将动画效果应用到<code>position</code>属性为<code>absolute</code>或<code>fixed</code>的元素上</li></ul></li><li>javascript<ul><li>避免频繁操作样式，可汇总后统一 <strong>一次修改</strong></li><li>尽量使用<code>class</code>进行样式修改</li><li>减少<code>dom</code>的增删次数，可使用 <strong>字符串</strong> 或者 <code>documentFragment</code> 一次性插入</li><li>极限优化时，修改样式可将其<code>display: none</code>后修改</li><li>避免多次触发上面提到的那些会触发回流的方法，可以的话尽量用 <strong>变量存住</strong></li></ul></li></ul><h3 id="6-存储">6. 存储</h3><p>我们经常需要对业务中的一些数据进行存储，通常可以分为 短暂性存储 和 持久性储存。</p><ul><li><p>短暂性的时候，我们只需要将数据存在内存中，只在运行时可用</p></li><li><p>持久性存储，可以分为 浏览器端 与 服务器端</p><ul><li><p>浏览器:</p><ul><li><p><code>cookie</code></p><p>: 通常用于存储用户身份，登录状态等</p><ul><li>http 中自动携带， 体积上限为 4K， 可自行设置过期时间</li></ul></li><li><p><code>localStorage / sessionStorage</code>: 长久储存/窗口关闭删除， 体积限制为 4~5M</p></li><li><p><code>indexDB</code></p></li></ul></li><li><p>服务器:</p><ul><li>分布式缓存 redis</li></ul></li><li><p>数据库</p></li></ul></li></ul><h3 id="7-Web-Worker">7. Web Worker</h3><p>现代浏览器为<code>JavaScript</code>创造的 <strong>多线程环境</strong>。可以新建并将部分任务分配到<code>worker</code>线程并行运行，两个线程可 <strong>独立运行，互不干扰</strong>，可通过自带的 <strong>消息机制</strong> 相互通信。</p><p><strong>基本用法:</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建 worker</span></span><br><span class="line"><span class="keyword">const</span> worker = <span class="keyword">new</span> Worker(<span class="string">'work.js'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向主进程推送消息</span></span><br><span class="line">worker.postMessage(<span class="string">'Hello World'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听主进程来的消息</span></span><br><span class="line">worker.onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Received message '</span> + event.data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>限制:</strong></p><ul><li>同源限制</li><li>无法使用 <code>document</code> / <code>window</code> / <code>alert</code> / <code>confirm</code></li><li>无法加载本地资源</li></ul><h3 id="8-V8垃圾回收机制">8. V8垃圾回收机制</h3><p>垃圾回收: 将内存中不再使用的数据进行清理，释放出内存空间。V8 将内存分成 <strong>新生代空间</strong> 和 <strong>老生代空间</strong>。</p><ul><li><p>新生代空间</p><p>: 用于存活较短的对象</p><ul><li>又分成两个空间: from 空间 与 to 空间</li><li>Scavenge GC算法: 当 from 空间被占满时，启动 GC 算法<ul><li>存活的对象从 from space 转移到 to space</li><li>清空 from space</li><li>from space 与 to space 互换</li><li>完成一次新生代GC</li></ul></li></ul></li><li><p>老生代空间</p><p>: 用于存活时间较长的对象</p><ul><li><p>从 新生代空间 转移到 老生代空间 的条件</p><ul><li>经历过一次以上 Scavenge GC 的对象</li><li>当 to space 体积超过25%</li></ul></li><li><p>标记清除算法</p><p>: 标记存活的对象，未被标记的则被释放</p><ul><li>增量标记: 小模块标记，在代码执行间隙执，GC 会影响性能</li><li>并发标记(最新技术): 不阻塞 js 执行</li></ul></li><li><p><strong>压缩算法</strong>: 将内存中清除后导致的碎片化对象往内存堆的一端移动，解决 <strong>内存的碎片化</strong></p></li></ul></li></ul><h3 id="9-内存泄露">9. 内存泄露</h3><ul><li>意外的<strong>全局变量</strong>: 无法被回收</li><li><strong>定时器</strong>: 未被正确关闭，导致所引用的外部变量无法被释放</li><li><strong>事件监听</strong>: 没有正确销毁 (低版本浏览器可能出现)</li><li><strong>闭包</strong>: 会导致父级中的变量无法被释放</li><li><strong>dom 引用</strong>: dom 元素被删除时，内存中的引用未被正确清空</li></ul><p>可用 chrome 中的 timeline 进行内存标记，可视化查看内存的变化情况，找出异常点。</p><h2 id="服务端与网络">服务端与网络</h2><h3 id="1-http-https-协议">1. http/https 协议</h3><ul><li>1.0 协议缺陷:<ul><li>无法复用链接，完成即断开，<strong>重新慢启动和 TCP 3次握手</strong></li><li>head of line blocking: <strong>线头阻塞</strong>，导致请求之间互相影响</li></ul></li><li>1.1 改进:<ul><li><strong>长连接</strong>(默认 keep-alive)，复用</li><li>host 字段指定对应的虚拟站点</li><li>新增功能:<ul><li>断点续传</li><li>身份认证</li><li>状态管理</li><li>cache 缓存<ul><li>Cache-Control</li><li>Expires</li><li>Last-Modified</li><li>Etag</li></ul></li></ul></li></ul></li><li>2.0:<ul><li>多路复用</li><li>二进制分帧层: 应用层和传输层之间</li><li>首部压缩</li><li>服务端推送</li></ul></li><li>https: 较为安全的网络传输协议<ul><li>证书(公钥)</li><li>SSL 加密</li><li>端口 443</li></ul></li><li>TCP:<ul><li>三次握手</li><li>四次挥手</li><li>滑动窗口: 流量控制</li><li>拥塞处理<ul><li>慢开始</li><li>拥塞避免</li><li>快速重传</li><li>快速恢复</li></ul></li></ul></li><li>缓存策略: 可分为 <strong>强缓存</strong> 和 <strong>协商缓存</strong><ul><li>Cache-Control/Expires: 浏览器判断缓存是否过期，未过期时，直接使用强缓存，<strong>Cache-Control的 max-age 优先级高于 Expires</strong></li><li>当缓存已经过期时，使用协商缓存<ul><li>唯一标识方案: Etag(response 携带) &amp; If-None-Match(request携带，上一次返回的 Etag): 服务器判断资源是否被修改，</li><li>最后一次修改时间: Last-Modified(response) &amp; If-Modified-Since (request，上一次返回的Last-Modified)<ul><li>如果一致，则直接返回 304 通知浏览器使用缓存</li><li>如不一致，则服务端返回新的资源</li></ul></li></ul></li><li>Last-Modified 缺点：<ul><li>周期性修改，但内容未变时，会导致缓存失效</li><li>最小粒度只到 s， s 以内的改动无法检测到</li></ul></li><li>Etag 的优先级高于 Last-Modified</li></ul></li></ul><h3 id="2-常见状态码">2. 常见状态码</h3><ul><li>1xx: 接受，继续处理</li><li>200: 成功，并返回数据</li><li>201: 已创建</li><li>202: 已接受</li><li>203: 成为，但未授权</li><li>204: 成功，无内容</li><li>205: 成功，重置内容</li><li>206: 成功，部分内容</li><li>301: 永久移动，重定向</li><li>302: 临时移动，可使用原有URI</li><li>304: 资源未修改，可使用缓存</li><li>305: 需代理访问</li><li>400: 请求语法错误</li><li>401: 要求身份认证</li><li>403: 拒绝请求</li><li>404: 资源不存在</li><li>500: 服务器错误</li></ul><h3 id="3-get-post">3. get / post</h3><ul><li>get: 缓存、请求长度受限、会被历史保存记录<ul><li>无副作用(不修改资源)，幂等(请求次数与资源无关)的场景</li></ul></li><li>post: 安全、大数据、更多编码类型</li></ul><p>两者详细对比如下图:</p><p><img src="5.png" alt=""></p><h3 id="4-Websocket">4. Websocket</h3><p>Websocket 是一个 <strong>持久化的协议</strong>， 基于 http ， 服务端可以 <strong>主动 push</strong></p><ul><li>兼容：<ul><li>FLASH Socket</li><li>长轮询： 定时发送 ajax</li><li>long poll： 发送 --&gt; 有消息时再 response</li></ul></li><li><code>new WebSocket(url)</code></li><li><code>ws.onerror = fn</code></li><li><code>ws.onclose = fn</code></li><li><code>ws.onopen = fn</code></li><li><code>ws.onmessage = fn</code></li><li><code>ws.send()</code></li></ul><h3 id="5-TCP三次握手">5. TCP三次握手</h3><p>建立连接前，客户端和服务端需要通过握手来确认对方:</p><ul><li>客户端发送 syn(同步序列编号) 请求，进入 syn_send 状态，等待确认</li><li>服务端接收并确认 syn 包后发送 syn+ack 包，进入 syn_recv 状态</li><li>客户端接收 syn+ack 包后，发送 ack 包，双方进入 established 状态</li></ul><h3 id="6-TCP四次挥手">6. TCP四次挥手</h3><ul><li>客户端 – FIN --&gt; 服务端， FIN—WAIT</li><li>服务端 – ACK --&gt; 客户端， CLOSE-WAIT</li><li>服务端 – ACK,FIN --&gt; 客户端， LAST-ACK</li><li>客户端 – ACK --&gt; 服务端，CLOSED</li></ul><h3 id="7-Node-的-Event-Loop-6个阶段">7. Node 的 Event Loop: 6个阶段</h3><ul><li><p>timer 阶段: 执行到期的<code>setTimeout / setInterval</code>队列回调</p></li><li><p>I/O 阶段: 执行上轮循环残流的<code>callback</code></p></li><li><p>idle, prepare</p></li><li><p>poll: 等待回调</p><ul><li><p>执行回调</p></li><li><p>执行定时器</p><p>如有到期的<code>setTimeout / setInterval</code>， 则返回 timer 阶段</p><p>如有<code>setImmediate</code>，则前往 check 阶段</p></li></ul></li><li><p>check</p><ul><li>执行<code>setImmediate</code></li></ul></li><li><p>close callbacks</p></li></ul><h3 id="跨域">跨域</h3><ul><li>JSONP: 利用<code>&lt;script&gt;</code>标签不受跨域限制的特点，缺点是只能支持 get 请求</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">jsonp</span>(<span class="params">url, jsonpCallback, success</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>)</span><br><span class="line">  script.src = url</span><br><span class="line">  script.async = <span class="literal">true</span></span><br><span class="line">  script.type = <span class="string">'text/javascript'</span></span><br><span class="line">  <span class="built_in">window</span>[jsonpCallback] = <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    success &amp;&amp; success(data)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(script)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>设置 CORS: Access-Control-Allow-Origin：*</li><li>postMessage</li></ul><h3 id="安全">安全</h3><ul><li>XSS攻击: 注入恶意代码<ul><li>cookie 设置 httpOnly</li><li>转义页面上的输入内容和输出内容</li></ul></li><li>CSRF: 跨站请求伪造，防护:<ul><li>get 不修改数据</li><li>不被第三方网站访问到用户的 cookie</li><li>设置白名单，不被第三方网站请求</li><li>请求校验</li></ul></li></ul><h2 id="框架：Vue">框架：Vue</h2><h3 id="1-nextTick">1. nextTick</h3><p>在下次<code>dom</code>更新循环结束之后执行延迟回调，可用于获取更新后的<code>dom</code>状态</p><ul><li>新版本中默认是<code>microtasks</code>, <code>v-on</code>中会使用<code>macrotasks</code></li><li><code>macrotasks</code>任务的实现:<ul><li><code>setImmediate / MessageChannel / setTimeout</code></li></ul></li></ul><h3 id="2-生命周期">2. 生命周期</h3><ul><li><p><code>_init_</code></p><ul><li><p><code>initLifecycle/Event</code>，往<code>vm</code>上挂载各种属性</p></li><li><p><code>callHook: beforeCreated</code>: 实例刚创建</p></li><li><p><code>initInjection/initState</code>: 初始化注入和 data 响应性</p></li><li><p><code>created</code>: 创建完成，属性已经绑定， 但还未生成真实<code>dom</code></p></li><li><p>进行元素的挂载： <code>$el / vm.$mount()</code></p></li><li><p>是否有template: 解析成render function</p><p>*.vue<code>文件:</code>vue-loader<code>会将</code><template><code>编译成</code>render function`</template></p></li><li><p><code>beforeMount</code>: 模板编译/挂载之前</p></li><li><p>执行<code>render function</code>，生成真实的<code>dom</code>，并替换到<code>dom tree</code>中</p></li><li><p><code>mounted</code>: 组件已挂载</p></li></ul></li><li><p><code>update</code>:</p><ul><li><p>执行<code>diff</code>算法，比对改变是否需要触发UI更新</p></li><li><p>flushScheduleQueue</p><ul><li><code>watcher.before</code>: 触发<code>beforeUpdate</code>钩子 - <code>watcher.run()</code>: 执行<code>watcher</code>中的 <code>notify</code>，通知所有依赖项更新UI</li></ul></li></ul></li><li><p>触发<code>updated</code>钩子: 组件已更新</p></li><li><p><code>actived / deactivated(keep-alive)</code>: 不销毁，缓存，组件激活与失活</p></li><li><p><code>destroy</code>:</p><ul><li><code>beforeDestroy</code>: 销毁开始</li><li>销毁自身且递归销毁子组件以及事件监听<ul><li><code>remove()</code>: 删除节点</li><li><code>watcher.teardown()</code>: 清空依赖</li><li><code>vm.$off()</code>: 解绑监听</li></ul></li><li><code>destroyed</code>: 完成后触发钩子</li></ul></li></ul><p>上面是<code>vue</code>的声明周期的简单梳理，接下来我们直接以代码的形式来完成<code>vue</code>的初始化</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化Vue实例</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_init</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	 <span class="comment">// 挂载属性</span></span><br><span class="line">    initLifeCycle(vm) </span><br><span class="line">    <span class="comment">// 初始化事件系统，钩子函数等</span></span><br><span class="line">    initEvent(vm) </span><br><span class="line">    <span class="comment">// 编译slot、vnode</span></span><br><span class="line">    initRender(vm) </span><br><span class="line">    <span class="comment">// 触发钩子</span></span><br><span class="line">    callHook(vm, <span class="string">'beforeCreate'</span>)</span><br><span class="line">    <span class="comment">// 添加inject功能</span></span><br><span class="line">    initInjection(vm)</span><br><span class="line">    <span class="comment">// 完成数据响应性 props/data/watch/computed/methods</span></span><br><span class="line">    initState(vm)</span><br><span class="line">    <span class="comment">// 添加 provide 功能</span></span><br><span class="line">    initProvide(vm)</span><br><span class="line">    <span class="comment">// 触发钩子</span></span><br><span class="line">    callHook(vm, <span class="string">'created'</span>)</span><br><span class="line">		</span><br><span class="line">	 <span class="comment">// 挂载节点</span></span><br><span class="line">    <span class="keyword">if</span> (vm.$options.el) &#123;</span><br><span class="line">        vm.$mount(vm.$options.el)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 挂载节点实现</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountComponent</span>(<span class="params">vm</span>) </span>&#123;</span><br><span class="line">	 <span class="comment">// 获取 render function</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.options.render) &#123;</span><br><span class="line">        <span class="comment">// template to render</span></span><br><span class="line">        <span class="comment">// Vue.compile = compileToFunctions</span></span><br><span class="line">        <span class="keyword">let</span> &#123; render &#125; = compileToFunctions() </span><br><span class="line">        <span class="keyword">this</span>.options.render = render</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 触发钩子</span></span><br><span class="line">    callHook(<span class="string">'beforeMounte'</span>)</span><br><span class="line">    <span class="comment">// 初始化观察者</span></span><br><span class="line">    <span class="comment">// render 渲染 vdom， </span></span><br><span class="line">    vdom = vm.render()</span><br><span class="line">    <span class="comment">// update: 根据 diff 出的 patchs 挂载成真实的 dom </span></span><br><span class="line">    vm._update(vdom)</span><br><span class="line">    <span class="comment">// 触发钩子  </span></span><br><span class="line">    callHook(vm, <span class="string">'mounted'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新节点实现</span></span><br><span class="line">funtion queueWatcher(watcher) &#123;</span><br><span class="line">	nextTick(flushScheduleQueue)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清空队列</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flushScheduleQueue</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	 <span class="comment">// 遍历队列中所有修改</span></span><br><span class="line">    <span class="keyword">for</span>()&#123;</span><br><span class="line">	    <span class="comment">// beforeUpdate</span></span><br><span class="line">        watcher.before()</span><br><span class="line">         </span><br><span class="line">        <span class="comment">// 依赖局部更新节点</span></span><br><span class="line">        watcher.update() </span><br><span class="line">        callHook(<span class="string">'updated'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 销毁实例实现</span></span><br><span class="line">Vue.prototype.$destory = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	 <span class="comment">// 触发钩子</span></span><br><span class="line">    callHook(vm, <span class="string">'beforeDestory'</span>)</span><br><span class="line">    <span class="comment">// 自身及子节点</span></span><br><span class="line">    remove() </span><br><span class="line">    <span class="comment">// 删除依赖</span></span><br><span class="line">    watcher.teardown() </span><br><span class="line">    <span class="comment">// 删除监听</span></span><br><span class="line">    vm.$off() </span><br><span class="line">    <span class="comment">// 触发钩子</span></span><br><span class="line">    callHook(vm, <span class="string">'destoryed'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-数据响应-数据劫持">3. 数据响应(数据劫持)</h3><p>看完生命周期后，里面的<code>watcher</code>等内容其实是数据响应中的一部分。数据响应的实现由两部分构成: <strong>观察者( watcher )</strong> 和 <strong>依赖收集器( Dep )</strong>，其核心是 <code>defineProperty</code>这个方法，它可以 <strong>重写属性的 get 与 set</strong> 方法，从而完成监听数据的改变。</p><ul><li><p>Observe (观察者)观察 props 与 state</p><ul><li>遍历 props 与 state，对每个属性创建独立的监听器( watcher )</li></ul></li><li><p>使用</p><p><code>defineProperty</code></p><p>重写每个属性的 get/set(</p><p><code>defineReactive</code></p><p>）</p><ul><li><p>get</p><p>: 收集依赖</p><ul><li>Dep.depend()</li><li><code>watcher.addDep()</code></li></ul></li></ul></li><li><p>set</p><p>: 派发更新</p><ul><li><code>Dep.notify()</code></li><li><code>watcher.update()</code></li><li><code>queenWatcher()</code><ul><li><code>nextTick</code></li></ul></li><li><code>flushScheduleQueue</code><ul><li><code>watcher.run()</code></li><li><code>updateComponent()</code></li></ul></li></ul></li></ul><p>大家可以先看下面的数据相应的代码实现后，理解后就比较容易看懂上面的简单脉络了。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> data = &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;</span><br><span class="line"><span class="comment">// 数据响应性</span></span><br><span class="line">observe(data)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化观察者</span></span><br><span class="line"><span class="keyword">new</span> Watcher(data, <span class="string">'name'</span>, updateComponent)</span><br><span class="line">data.a = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 简单表示用于数据更新后的操作</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateComponent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    vm._update() <span class="comment">// patchs</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监视对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">observe</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">	 <span class="comment">// 遍历对象，使用 get/set 重新定义对象的每个属性值</span></span><br><span class="line">    <span class="built_in">Object</span>.keys(obj).map(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">        defineReactive(obj, key, obj[key])</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span>(<span class="params">obj, k, v</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 递归子属性</span></span><br><span class="line">    <span class="keyword">if</span> (type(v) == <span class="string">'object'</span>) observe(v)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 新建依赖收集器</span></span><br><span class="line">    <span class="keyword">let</span> dep = <span class="keyword">new</span> Dep()</span><br><span class="line">    <span class="comment">// 定义get/set</span></span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(obj, k, &#123;</span><br><span class="line">        enumerable: <span class="literal">true</span>,</span><br><span class="line">        configurable: <span class="literal">true</span>,</span><br><span class="line">        <span class="keyword">get</span>: function reactiveGetter() &#123;</span><br><span class="line">        	  <span class="comment">// 当有获取该属性时，证明依赖于该对象，因此被添加进收集器中</span></span><br><span class="line">            <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">                dep.addSub(Dep.target)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> v</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// 重新设置值时，触发收集器的通知机制</span></span><br><span class="line">        <span class="keyword">set</span>: function reactiveSetter(nV) &#123;</span><br><span class="line">            v = nV</span><br><span class="line">            dep.nofify()</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 依赖收集器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">this</span>.subs = []</span><br><span class="line">    &#125;</span><br><span class="line">    addSub(sub) &#123;</span><br><span class="line">        <span class="keyword">this</span>.subs.push(sub)</span><br><span class="line">    &#125;</span><br><span class="line">    notify() &#123;</span><br><span class="line">        <span class="keyword">this</span>.subs.map(<span class="function"><span class="params">sub</span> =&gt;</span> &#123;</span><br><span class="line">            sub.update()</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Dep.target = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 观察者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(obj, key, cb) &#123;</span><br><span class="line">        Dep.target = <span class="keyword">this</span></span><br><span class="line">        <span class="keyword">this</span>.cb = cb</span><br><span class="line">        <span class="keyword">this</span>.obj = obj</span><br><span class="line">        <span class="keyword">this</span>.key = key</span><br><span class="line">        <span class="keyword">this</span>.value = obj[key]</span><br><span class="line">        Dep.target = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    addDep(Dep) &#123;</span><br><span class="line">        Dep.addSub(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    update() &#123;</span><br><span class="line">        <span class="keyword">this</span>.value = <span class="keyword">this</span>.obj[<span class="keyword">this</span>.key]</span><br><span class="line">        <span class="keyword">this</span>.cb(<span class="keyword">this</span>.value)</span><br><span class="line">    &#125;</span><br><span class="line">    before() &#123;</span><br><span class="line">        callHook(<span class="string">'beforeUpdate'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-virtual-dom-原理实现">4. virtual dom 原理实现</h3><ul><li><p>创建 dom 树</p></li><li><p>树的<code>diff</code>，同层对比，输出<code>patchs(listDiff/diffChildren/diffProps)</code></p><ul><li><p>没有新的节点，返回</p></li><li><p>新的节点</p><p><code>tagName</code>与<code>key</code>不变， 对比<code>props</code>，继续递归遍历子树</p><ul><li>对比属性(对比新旧属性列表):</li></ul></li><li><p>旧属性是否存在与新属性列表中</p><ul><li>都存在的是否有变化</li></ul></li><li><p>是否出现旧列表中没有的新属性</p></li><li><p><code>tagName</code>和<code>key</code>值变化了，则直接替换成新节点</p></li></ul></li><li><p>渲染差异</p><ul><li>遍历<code>patchs</code>， 把需要更改的节点取出来</li><li>局部更新<code>dom</code></li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// diff算法的实现</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">diff</span>(<span class="params">oldTree, newTree</span>) </span>&#123;</span><br><span class="line">	 <span class="comment">// 差异收集</span></span><br><span class="line">    <span class="keyword">let</span> pathchs = &#123;&#125;</span><br><span class="line">    dfs(oldTree, newTree, <span class="number">0</span>, pathchs)</span><br><span class="line">    <span class="keyword">return</span> pathchs</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">oldNode, newNode, index, pathchs</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> curPathchs = []</span><br><span class="line">    <span class="keyword">if</span> (newNode) &#123;</span><br><span class="line">        <span class="comment">// 当新旧节点的 tagName 和 key 值完全一致时</span></span><br><span class="line">        <span class="keyword">if</span> (oldNode.tagName === newNode.tagName &amp;&amp; oldNode.key === newNode.key) &#123;</span><br><span class="line">        	  <span class="comment">// 继续比对属性差异</span></span><br><span class="line">            <span class="keyword">let</span> props = diffProps(oldNode.props, newNode.props)</span><br><span class="line">            curPathchs.push(&#123; <span class="attr">type</span>: <span class="string">'changeProps'</span>, props &#125;)</span><br><span class="line">            <span class="comment">// 递归进入下一层级的比较</span></span><br><span class="line">            diffChildrens(oldNode.children, newNode.children, index, pathchs)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        	  <span class="comment">// 当 tagName 或者 key 修改了后，表示已经是全新节点，无需再比</span></span><br><span class="line">            curPathchs.push(&#123; <span class="attr">type</span>: <span class="string">'replaceNode'</span>, <span class="attr">node</span>: newNode &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	 <span class="comment">// 构建出整颗差异树</span></span><br><span class="line">    <span class="keyword">if</span> (curPathchs.length) &#123;</span><br><span class="line">    		<span class="keyword">if</span>(pathchs[index])&#123;</span><br><span class="line">    			pathchs[index] = pathchs[index].concat(curPathchs)</span><br><span class="line">    		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    			pathchs[index] = curPathchs</span><br><span class="line">    		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 属性对比实现</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">diffProps</span>(<span class="params">oldProps, newProps</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> propsPathchs = []</span><br><span class="line">    <span class="comment">// 遍历新旧属性列表</span></span><br><span class="line">    <span class="comment">// 查找删除项</span></span><br><span class="line">    <span class="comment">// 查找修改项</span></span><br><span class="line">    <span class="comment">// 查找新增项</span></span><br><span class="line">    forin(olaProps, (k, v) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (!newProps.hasOwnProperty(k)) &#123;</span><br><span class="line">            propsPathchs.push(&#123; <span class="attr">type</span>: <span class="string">'remove'</span>, <span class="attr">prop</span>: k &#125;)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (v !== newProps[k]) &#123;</span><br><span class="line">                propsPathchs.push(&#123; <span class="attr">type</span>: <span class="string">'change'</span>, <span class="attr">prop</span>: k , <span class="attr">value</span>: newProps[k] &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    forin(newProps, (k, v) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (!oldProps.hasOwnProperty(k)) &#123;</span><br><span class="line">            propsPathchs.push(&#123; <span class="attr">type</span>: <span class="string">'add'</span>, <span class="attr">prop</span>: k, <span class="attr">value</span>: v &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> propsPathchs</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对比子级差异</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">diffChildrens</span>(<span class="params">oldChild, newChild, index, pathchs</span>) </span>&#123;</span><br><span class="line">		<span class="comment">// 标记子级的删除/新增/移动</span></span><br><span class="line">    <span class="keyword">let</span> &#123; change, list &#125; = diffList(oldChild, newChild, index, pathchs)</span><br><span class="line">    <span class="keyword">if</span> (change.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pathchs[index]) &#123;</span><br><span class="line">            pathchs[index] = pathchs[index].concat(change)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pathchs[index] = change</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	 <span class="comment">// 根据 key 获取原本匹配的节点，进一步递归从头开始对比</span></span><br><span class="line">    oldChild.map(<span class="function">(<span class="params">item, i</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> keyIndex = list.indexOf(item.key)</span><br><span class="line">        <span class="keyword">if</span> (keyIndex) &#123;</span><br><span class="line">            <span class="keyword">let</span> node = newChild[keyIndex]</span><br><span class="line">            <span class="comment">// 进一步递归对比</span></span><br><span class="line">            dfs(item, node, index, pathchs)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 列表对比，主要也是根据 key 值查找匹配项</span></span><br><span class="line"><span class="comment">// 对比出新旧列表的新增/删除/移动</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">diffList</span>(<span class="params">oldList, newList, index, pathchs</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> change = []</span><br><span class="line">    <span class="keyword">let</span> list = []</span><br><span class="line">    <span class="keyword">const</span> newKeys = getKey(newList)</span><br><span class="line">    oldList.map(<span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (newKeys.indexOf(v.key) &gt; <span class="number">-1</span>) &#123;</span><br><span class="line">            list.push(v.key)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            list.push(<span class="literal">null</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 标记删除</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = list.length - <span class="number">1</span>; i&gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!list[i]) &#123;</span><br><span class="line">            list.splice(i, <span class="number">1</span>)</span><br><span class="line">            change.push(&#123; <span class="attr">type</span>: <span class="string">'remove'</span>, <span class="attr">index</span>: i &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 标记新增和移动</span></span><br><span class="line">    newList.map(<span class="function">(<span class="params">item, i</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> key = item.key</span><br><span class="line">        <span class="keyword">const</span> index = list.indexOf(key)</span><br><span class="line">        <span class="keyword">if</span> (index === <span class="number">-1</span> || key == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 新增</span></span><br><span class="line">            change.push(&#123; <span class="attr">type</span>: <span class="string">'add'</span>, <span class="attr">node</span>: item, <span class="attr">index</span>: i &#125;)</span><br><span class="line">            list.splice(i, <span class="number">0</span>, key)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 移动</span></span><br><span class="line">            <span class="keyword">if</span> (index !== i) &#123;</span><br><span class="line">                change.push(&#123;</span><br><span class="line">                    type: <span class="string">'move'</span>,</span><br><span class="line">                    form: index,</span><br><span class="line">                    to: i,</span><br><span class="line">                &#125;)</span><br><span class="line">                move(list, index, i)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123; change, list &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-Proxy-相比于-defineProperty-的优势">5. Proxy 相比于 defineProperty 的优势</h3><ul><li>数组变化也能监听到</li><li>不需要深度遍历监听</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> data = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;</span><br><span class="line"><span class="keyword">let</span> reactiveData = <span class="keyword">new</span> <span class="built_in">Proxy</span>(data, &#123;</span><br><span class="line">	<span class="keyword">get</span>: function(target, name)&#123;</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="6-vue-router">6. vue-router</h3><ul><li><p>mode</p><ul><li><code>hash</code></li><li><code>history</code></li></ul></li><li><p>跳转</p><ul><li><code>this.$router.push()</code></li><li><code>&lt;router-link to=&quot;&quot;&gt;&lt;/router-link&gt;</code></li></ul></li><li><p>占位</p><ul><li><code>&lt;router-view&gt;&lt;/router-view&gt;</code></li></ul></li></ul><h3 id="7-vuex">7. vuex</h3><ul><li><code>state</code>: 状态中心</li><li><code>mutations</code>: 更改状态</li><li><code>actions</code>: 异步更改状态</li><li><code>getters</code>: 获取状态</li><li><code>modules</code>: 将<code>state</code>分成多个<code>modules</code>，便于管理</li></ul><h2 id="算法">算法</h2><p>其实算法方面在前端的实际项目中涉及得并不多，但还是需要精通一些基础性的算法，一些公司还是会有这方面的需求和考核，建议大家还是需要稍微准备下，这属于加分题。</p><h3 id="1-五大算法">1. 五大算法</h3><ul><li><strong>贪心算法</strong>: 局部最优解法</li><li><strong>分治算法</strong>: 分成多个小模块，与原问题性质相同</li><li><strong>动态规划</strong>: 每个状态都是过去历史的一个总结</li><li><strong>回溯法</strong>: 发现原先选择不优时，退回重新选择</li><li><strong>分支限界法</strong></li></ul><h3 id="2-基础排序算法">2. 基础排序算法</h3><ul><li>冒泡排序: 两两比较</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubleSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> len = arr.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> outer = len ; outer &gt;= <span class="number">2</span>; outer--) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> inner = <span class="number">0</span>; inner &lt;=outer - <span class="number">1</span>; inner++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[inner] &gt; arr[inner + <span class="number">1</span>]) &#123;</span><br><span class="line">                [arr[inner],arr[inner+<span class="number">1</span>]] = [arr[inner+<span class="number">1</span>],arr[inner]]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>选择排序: 遍历自身以后的元素，最小的元素跟自己调换位置</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">selectSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> len = arr.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span> ;i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j = i ; j&lt;len; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j] &lt; arr[i]) &#123;</span><br><span class="line">                [arr[i],arr[j]] = [arr[j],arr[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>插入排序: 即将元素插入到已排序好的数组中</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;  <span class="comment">//外循环从1开始，默认arr[0]是有序段</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j = i; j &gt; <span class="number">0</span>; j--) &#123;  <span class="comment">//j = i,将arr[j]依次插入有序段中</span></span><br><span class="line">            <span class="keyword">if</span>(arr[j] &lt; arr[j<span class="number">-1</span>]) &#123;</span><br><span class="line">                [arr[j],arr[j<span class="number">-1</span>]] = [arr[j<span class="number">-1</span>],arr[j]];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-高级排序算法">3. 高级排序算法</h3><ul><li>快速排序<ul><li>选择基准值(base)，原数组长度减一(基准值)，使用 splice</li><li>循环原数组，小的放左边(left数组)，大的放右边(right数组);</li><li>concat(left, base, right)</li><li>递归继续排序 left 与 right</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quickSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr.length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> arr;  <span class="comment">//递归出口</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> left = [],</span><br><span class="line">        right = [],</span><br><span class="line">        current = arr.splice(<span class="number">0</span>,<span class="number">1</span>); </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i] &lt; current) &#123;</span><br><span class="line">            left.push(arr[i])  <span class="comment">//放在左边</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right.push(arr[i]) <span class="comment">//放在右边</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> quickSort(left).concat(current,quickSort(right));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>希尔排序：不定步数的插入排序，插入排序</li><li>口诀: 插冒归基稳定，快选堆希不稳定</li></ul><p><img src="6.png" alt=""></p><p>稳定性： 同大小情况下是否可能会被交换位置, 虚拟dom的diff，不稳定性会导致重新渲染；</p><h3 id="4-递归运用-斐波那契数列-：-爬楼梯问题">4. 递归运用(斐波那契数列)： 爬楼梯问题</h3><p>初始在第一级，到第一级有1种方法(s(1) = 1)，到第二级也只有一种方法(s(2) = 1)， 第三级(s(3) = s(1) + s(2))</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cStairs</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n === <span class="number">1</span> || n === <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> cStairs(n<span class="number">-1</span>) + cStairs(n<span class="number">-2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-数据树">5. 数据树</h3><ul><li>二叉树: 最多只有两个子节点<ul><li>完全二叉树</li><li>满二叉树<ul><li>深度为 h, 有 n 个节点，且满足 n = 2^h - 1</li></ul></li></ul></li><li>二叉查找树: 是一种特殊的二叉树，能有效地提高查找效率<ul><li>小值在左，大值在右</li><li>节点 n 的所有左子树值小于 n，所有右子树值大于 n</li></ul></li></ul><p><img src="7.png" alt=""></p><ul><li>遍历节点<ul><li>前序遍历<ul><li>根节点</li><li>访问左子节点，回到 1</li><li>访问右子节点，回到 1</li></ul></li><li>中序遍历<ul><li>先访问到最左的子节点</li><li>访问该节点的父节点</li><li>访问该父节点的右子节点， 回到 1</li></ul></li><li>后序遍历<ul><li>先访问到最左的子节点</li><li>访问相邻的右节点</li><li>访问父节点， 回到 1</li></ul></li></ul></li><li>插入与删除节点</li></ul><h3 id="6-天平找次品">6. 天平找次品</h3><p>有n个硬币，其中1个为假币，假币重量较轻，你有一把天平，请问，至少需要称多少次能保证一定找到假币?</p><ul><li><p>三等分算法:</p><ul><li>将硬币分成3组，随便取其中两组天平称量</li></ul></li><li><p>平衡，假币在未上称的一组，取其回到 1 继续循环</p><ul><li>不平衡，假币在天平上较轻的一组， 取其回到 1 继续循环</li></ul></li></ul><!-- rebuild by neat -->]]></content>
      <categories>
        <category>前端</category>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo优化静态JS等资源压缩博客</title>
    <url>/posts/301aa5fe/</url>
    <content><![CDATA[<!-- build time:Mon Mar 09 2020 17:05:46 GMT+0800 (GMT+08:00) --><h3 id="center-概述-通过技术手段优化hexo博客❤️-center"><center>概述:通过技术手段优化hexo博客❤️</center></h3><a id="more"></a><p>通过技术手段优化hexo博客，达到提高访问速度是很有必要的，下面我们来看下用hexo-neat开源软件来压缩hexo静态资源</p><p>为什么需要压缩静态资源，包括js、css、html、图片等来实现提高性能的原因，这里就不再叙述了</p><h3 id="安装hexo-neat开源软件😄">安装hexo-neat开源软件😄</h3><p>安装命令是：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-neat --save</span><br></pre></td></tr></table></figure><p>安装失败的话，查看下是否有网络权限等原因<br>安装成功的话，继续下面步骤</p><h3 id="配置hexo-config-yml配置😄">配置hexo _config.yml配置😄</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># hexo-neat 压缩</span></span><br><span class="line"><span class="attr">neat_enable:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 压缩html</span></span><br><span class="line"><span class="attr">neat_html:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">exclude:</span></span><br><span class="line"><span class="comment"># 压缩css  </span></span><br><span class="line"><span class="attr">neat_css:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">exclude:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">'**/*.min.css'</span></span><br><span class="line"><span class="comment"># 压缩js</span></span><br><span class="line"><span class="attr">neat_js:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">mangle:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">output:</span></span><br><span class="line">  <span class="attr">compress:</span></span><br><span class="line">  <span class="attr">exclude:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">'**/*.min.js'</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">'**/jquery.fancybox.pack.js'</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">'**/index.js'</span></span><br></pre></td></tr></table></figure><p>完成之后，重新执行下命令查看是否压缩成功😙</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br></pre></td></tr></table></figure><p>另外一种方式:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-all-minifier --save</span><br></pre></td></tr></table></figure><p>在hexo根目录下的<br>_config.yml中配置😄:</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码压缩 github.com/chenzhutian/hexo-all-minifier</span></span><br><span class="line"><span class="attr">all_minifier:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="attr">html_minifier:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">ignore_error:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">exclude:</span></span><br><span class="line">  </span><br><span class="line"><span class="attr">css_minifier:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">exclude:</span> </span><br><span class="line">    <span class="bullet">-</span> <span class="string">'*.min.css'</span></span><br><span class="line"></span><br><span class="line"><span class="attr">js_minifier:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">mangle:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">output:</span></span><br><span class="line">  <span class="attr">compress:</span></span><br><span class="line">  <span class="attr">exclude:</span> </span><br><span class="line">    <span class="bullet">-</span> <span class="string">'*.min.js'</span></span><br><span class="line"></span><br><span class="line"><span class="attr">image_minifier:</span> </span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span> <span class="comment"># 图片不压缩</span></span><br><span class="line">  <span class="attr">interlaced:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">multipass:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">optimizationLevel:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">pngquant:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">progressive:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo NexT开启emoji</title>
    <url>/posts/66cb08ab/</url>
    <content><![CDATA[<!-- build time:Mon Mar 09 2020 17:05:46 GMT+0800 (GMT+08:00) --><h4 id="center-Hexo-开启欢乐的-emoji之旅💛-center"><center>Hexo 开启欢乐的 emoji之旅💛</center></h4><a id="more"></a><p>Hexo 默认的 markdown 渲染引擎不支持将 Github emoji 渲染到静态的 html 页面中，我们换一个支持 emoji 的引擎，再增加一个 emoji 插件即可</p><h4 id="安装">安装</h4><p>命令行如下:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm uninstall hexo-renderer-marked --save</span><br><span class="line">npm install hexo-renderer-markdown-it --save</span><br><span class="line">npm install markdown-it-emoji --save</span><br></pre></td></tr></table></figure><p>Tips: 据说<a href="https://github.com/hexojs/hexo-renderer-markdown-it" target="_blank" rel="noopener">hexo-renderer-markdown-it</a>👈的速度要比 Hexo 原装插件要快，而且功能更多</p><h4 id="配置">配置</h4><p>完成插件安装后还需要修改 Hexo 站点配置文档 <code>_config.yml</code>在末尾处添加以下代码（不是主题配置哦）🙂</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">markdown:</span></span><br><span class="line">  <span class="attr">render:</span></span><br><span class="line">    <span class="attr">html:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">xhtmlOut:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">breaks:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">linkify:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">typographer:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">quotes:</span> <span class="string">'“”‘’'</span></span><br><span class="line">  <span class="attr">plugins:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">markdown-it-footnote</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">markdown-it-sup</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">markdown-it-sub</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">markdown-it-abbr</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">markdown-it-emoji</span></span><br><span class="line">  <span class="attr">anchors:</span></span><br><span class="line">    <span class="attr">level:</span> <span class="number">2</span></span><br><span class="line">    <span class="attr">collisionSuffix:</span> <span class="string">'v'</span></span><br><span class="line">    <span class="attr">permalink:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">permalinkClass:</span> <span class="string">header-anchor</span></span><br><span class="line">    <span class="attr">permalinkSymbol:</span> <span class="string">¶</span></span><br></pre></td></tr></table></figure><p>这里需要注意 <code>render:</code> 下的 <code>html:</code> 配置项，它的作用是控制 <code>Markdown</code> 渲染引擎是否转义文档中出现的 <code>html</code> 标签，默认为 <code>false</code> ，这里要设置为 <code>true</code>，否则回导致 <code>&lt;!--more--&gt;</code> 渲染失败。</p><p><code>plugins:</code> 中的最后一项 <code>- markdown-it-emoji</code>是手动添加的，官方 Github Wiki 中给出的配置不包含这一项，其他配置参照的 Github Wiki 中的默认配置，hexo-renderer-markdown-it 提供的其他新特性还没有一一尝试，暂时只想用它的 emoji 功能。</p><h4 id="使用方法">使用方法</h4><ol><li>在<a href="https://www.cnblogs.com/wangjs-jacky/p/12011208.html" target="_blank" rel="noopener">这篇博客介绍的Emoji</a> 中找到你想要的表情，然后点击复制粘贴。</li><li>常用的emoji可以记下它的编码，直接输入，例如直接输入笑脸对应的 emoji 编码 <code>:smile:</code> 就可以得到 😄 。</li></ol><!-- rebuild by neat -->]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
        <tag>主题美化</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo+Github博客</title>
    <url>/posts/831fde7a/</url>
    <content><![CDATA[<!-- build time:Mon Mar 09 2020 17:05:46 GMT+0800 (GMT+08:00) --><h2 id="center-概述-网站内图片不能正常显示，但本地文件可以显示-center"><center>概述:网站内图片不能正常显示，但本地文件可以显示</center></h2><a id="more"></a><p>1.1 问题描述<br>markdown文件中，插入图片的方式为 <code>![](文件路径)</code>，此时markdown文件可以正常显示图片。<br>但是一上传到博客上，便不能正常显示。</p><p>1.2 解决办法<br>1.修改 hexo 目录下的 .config.yml 文件，<br>将 <code>post_asset_folder: false</code> 修改为 <code>post_asset_folder: true</code>。</p><p>2.安装一个图片路径转换的插件。<br>在hexo文件夹下打开 Git bush。输入</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install https:&#x2F;&#x2F;github.com&#x2F;7ym0n&#x2F;hexo-asset-image --save</span><br></pre></td></tr></table></figure><p>注意： 这使经过修改的插件代码，网上流传的另一份代码</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install https:&#x2F;&#x2F;github.com&#x2F;CodeFalling&#x2F;hexo-asset-image --save</span><br></pre></td></tr></table></figure><p>并不能使用。</p><p>如果你之前安装了这个错误的插件，请将 /node_modules/hexo-asset-image/index.js<br>这个文件替换成下面的代码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"><span class="keyword">var</span> cheerio = <span class="built_in">require</span>(<span class="string">'cheerio'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-string</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPosition</span>(<span class="params">str, m, i</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> str.split(m, i).join(m).length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> version = <span class="built_in">String</span>(hexo.version).split(<span class="string">'.'</span>);</span><br><span class="line">hexo.extend.filter.register(<span class="string">'after_post_render'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> config = hexo.config;</span><br><span class="line"><span class="keyword">if</span>(config.post_asset_folder)&#123;</span><br><span class="line">    <span class="keyword">var</span> link = data.permalink;</span><br><span class="line"><span class="keyword">if</span>(version.length &gt; <span class="number">0</span> &amp;&amp; <span class="built_in">Number</span>(version[<span class="number">0</span>]) == <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">var</span> beginPos = getPosition(link, <span class="string">'/'</span>, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">var</span> beginPos = getPosition(link, <span class="string">'/'</span>, <span class="number">3</span>) + <span class="number">1</span>;</span><br><span class="line"><span class="comment">// In hexo 3.1.1, the permalink of "about" page is like ".../about/index.html".</span></span><br><span class="line"><span class="keyword">var</span> endPos = link.lastIndexOf(<span class="string">'/'</span>) + <span class="number">1</span>;</span><br><span class="line">link = link.substring(beginPos, endPos);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> toprocess = [<span class="string">'excerpt'</span>, <span class="string">'more'</span>, <span class="string">'content'</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; toprocess.length; i++)&#123;</span><br><span class="line">    <span class="keyword">var</span> key = toprocess[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> $ = cheerio.load(data[key], &#123;</span><br><span class="line">    ignoreWhitespace: <span class="literal">false</span>,</span><br><span class="line">    xmlMode: <span class="literal">false</span>,</span><br><span class="line">    lowerCaseTags: <span class="literal">false</span>,</span><br><span class="line">    decodeEntities: <span class="literal">false</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    $(<span class="string">'img'</span>).each(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ($(<span class="keyword">this</span>).attr(<span class="string">'src'</span>))&#123;</span><br><span class="line">        <span class="comment">// For windows style path, we replace '\' to '/'.</span></span><br><span class="line">        <span class="keyword">var</span> src = $(<span class="keyword">this</span>).attr(<span class="string">'src'</span>).replace(<span class="string">'\\'</span>, <span class="string">'/'</span>);</span><br><span class="line">        <span class="keyword">if</span>(!<span class="regexp">/http[s]*.*|\/\/.*/</span>.test(src) &amp;&amp;</span><br><span class="line">            !<span class="regexp">/^\s*\//</span>.test(src)) &#123;</span><br><span class="line">            <span class="comment">// For "about" page, the first part of "src" can't be removed.</span></span><br><span class="line">            <span class="comment">// In addition, to support multi-level local directory.</span></span><br><span class="line">            <span class="keyword">var</span> linkArray = link.split(<span class="string">'/'</span>).filter(<span class="function"><span class="keyword">function</span>(<span class="params">elem</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> elem != <span class="string">''</span>;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">var</span> srcArray = src.split(<span class="string">'/'</span>).filter(<span class="function"><span class="keyword">function</span>(<span class="params">elem</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> elem != <span class="string">''</span> &amp;&amp; elem != <span class="string">'.'</span>;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">if</span>(srcArray.length &gt; <span class="number">1</span>)</span><br><span class="line">            srcArray.shift();</span><br><span class="line">            src = srcArray.join(<span class="string">'/'</span>);</span><br><span class="line">            $(<span class="keyword">this</span>).attr(<span class="string">'src'</span>, config.root + link + src);</span><br><span class="line">            <span class="built_in">console</span>.info&amp;&amp;<span class="built_in">console</span>.info(<span class="string">"update link as:--&gt;"</span>+config.root + link + src);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.info&amp;&amp;<span class="built_in">console</span>.info(<span class="string">"no src attr, skipped..."</span>);</span><br><span class="line">        <span class="built_in">console</span>.info&amp;&amp;<span class="built_in">console</span>.info($(<span class="keyword">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    data[key] = $.html();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>3.安装完上述插件后，当我们创建新文章时 hexo new post “new article” ，就自动在 new <a href="http://article.md/" target="_blank" rel="noopener">article.md</a> 文件的同目录下创建一个同名的文件夹，这里就是文件夹 new article 。我们把在 new <a href="http://article.md/" target="_blank" rel="noopener">article.md</a> 使用的图片放入该文件夹中。<br>我们的文件目录如下所示：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">|- _post  |    |- pictures|    |    |- hexo.png|    |- new article  |    |    |- hexo.png  |    |- new article.md</span><br></pre></td></tr></table></figure><p>4.这里我们给出两种办法来引用图片。</p><p>直接使用代码 <code>![](hexo.png)</code> （虽然没有写文件夹的名字，但是可以的），hexo.png 是我们存在 new article 文件夹内的图片。这时你会发现markdown预览中无法显示这张图片，但是当你将博客上传到网站时，网站上是可以正常显示的。<br>使用代码 <code>![](new article/hexo.png)</code>不仅可以本地预览，上传到网站也可以正常显示。<br>本地无法预览也是件很不舒服的事情，其实我们还可以另外创建一个文件夹 pictures ，里面专门存放所有文章的图片，代码 <code>![](pictures/hexo.png)</code> 不仅可以本地预览，上传到网站也可以正常显示。<br>注意： 不管采取哪种办法，都要创建一个和md文件同名的文件夹，里面放上需要的图片。<br>如果 2和3 中代码无法实现网站上的正常显示，那就使用 1 中的代码。<br>因为 2和3 中代码我无法保证每个人都成功。<br>参考及转载:<a href="https://blog.csdn.net/qq_36408085/article/details/104117319" target="_blank" rel="noopener">神奇小海螺</a></p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>gulp压缩--imagemin</title>
    <url>/posts/1693b9cb/</url>
    <content><![CDATA[<!-- build time:Mon Mar 09 2020 17:05:46 GMT+0800 (GMT+08:00) --><h4 id="center-概述-关于-TypeError-imagemin-jpegtran-is-not-a-function😤-center"><center>概述:关于 <strong>TypeError: imagemin.jpegtran is not a function</strong>😤</center></h4><a id="more"></a><p>因为最近刚搭建好博客，想着以后更新也会很频繁，文章太多不利于浏览，于是想到了利用Gulp自动构建工具压缩静态资源</p><p>于是开始下面的安装之旅🙂</p><h4 id="1-全局安装gulp">1.全局安装gulp</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install gulp -g# 查看版本gulp -v</span><br></pre></td></tr></table></figure><h4 id="2-安装gulp插件">2.安装gulp插件</h4><p>在博客站点目录下安装以下插件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install gulp --save</span><br><span class="line">npm install gulp-minify-css --save</span><br><span class="line">npm install gulp-uglify --save</span><br><span class="line">npm install gulp-htmlmin --save</span><br><span class="line">npm install gulp-htmlclean --save</span><br><span class="line">npm install gulp-imagemin --save</span><br><span class="line"># 解决【Gulp打包问题】 GulpUglifyError: unable to minify JavaScript</span><br><span class="line"># 解决 gulp-uglify 压缩JavaScript 不兼容 es5 语法的问题</span><br><span class="line">npm install babel-core@6.26.3 --save</span><br><span class="line">npm install gulp-babel@7.0.1 --save</span><br><span class="line">npm install babel-preset-es2015@6.24.1 --save</span><br><span class="line"># gulp-babel 取消严格模式方法(&quot;use strict&quot;)</span><br><span class="line">npm install babel-plugin-transform-remove-strict-mode --save</span><br></pre></td></tr></table></figure><p>问题：如果安装<code>gulp-imagemin</code>错误请执行以下语句<br><code>sudo npm i gulp-imagemin --unsafe-perms</code></p><h4 id="3-创建gulpfile-js文件">3.创建<code>gulpfile.js</code>文件</h4><p>在 <code>Hexo</code> 站点目录下新建<code>gulpfile.js</code>文件，文件内容如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</span><br><span class="line"><span class="keyword">var</span> minifycss = <span class="built_in">require</span>(<span class="string">'gulp-minify-css'</span>);</span><br><span class="line"><span class="keyword">var</span> uglify = <span class="built_in">require</span>(<span class="string">'gulp-uglify'</span>);</span><br><span class="line"><span class="keyword">var</span> htmlmin = <span class="built_in">require</span>(<span class="string">'gulp-htmlmin'</span>);</span><br><span class="line"><span class="keyword">var</span> htmlclean = <span class="built_in">require</span>(<span class="string">'gulp-htmlclean'</span>);</span><br><span class="line"><span class="keyword">var</span> imagemin = <span class="built_in">require</span>(<span class="string">'gulp-imagemin'</span>);</span><br><span class="line"><span class="keyword">var</span> babel = <span class="built_in">require</span>(<span class="string">'gulp-babel'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 压缩css文件</span></span><br><span class="line">gulp.task(<span class="string">'minify-css'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">done</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gulp.src(<span class="string">'./public/**/*.css'</span>)</span><br><span class="line">        .pipe(minifycss())</span><br><span class="line">        .pipe(gulp.dest(<span class="string">'./public'</span>));</span><br><span class="line">    done();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 压缩html文件</span></span><br><span class="line">gulp.task(<span class="string">'minify-html'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">done</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gulp.src(<span class="string">'./public/**/*.html'</span>)</span><br><span class="line">        .pipe(htmlclean())</span><br><span class="line">        .pipe(htmlmin(&#123;</span><br><span class="line">            removeComments: <span class="literal">true</span>,</span><br><span class="line">            minifyJS: <span class="literal">true</span>,</span><br><span class="line">            minifyCSS: <span class="literal">true</span>,</span><br><span class="line">            minifyURLs: <span class="literal">true</span>,</span><br><span class="line">        &#125;))</span><br><span class="line">        .pipe(gulp.dest(<span class="string">'./public'</span>));</span><br><span class="line">    done();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 压缩js文件</span></span><br><span class="line">gulp.task(<span class="string">'minify-js'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">done</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gulp.src([<span class="string">'./public/**/*.js'</span>, <span class="string">'!./public/**/*.min.js'</span>])</span><br><span class="line">        .pipe(babel(&#123;</span><br><span class="line">            <span class="comment">//将ES6代码转译为可执行的JS代码</span></span><br><span class="line">            presets: [<span class="string">'es2015'</span>] <span class="comment">// es5检查机制</span></span><br><span class="line">        &#125;))</span><br><span class="line">        .pipe(uglify())</span><br><span class="line">        .pipe(gulp.dest(<span class="string">'./public'</span>));</span><br><span class="line">    done();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 压缩 public/images 目录内图片(Version&lt;3)</span></span><br><span class="line"><span class="comment">// gulp.task('minify-images', function () &#123;</span></span><br><span class="line"><span class="comment">//     gulp.src('./public/images/**/*.*')</span></span><br><span class="line"><span class="comment">//         .pipe(imagemin(&#123;</span></span><br><span class="line"><span class="comment">//             optimizationLevel: 5, //类型：Number  默认：3  取值范围：0-7（优化等级）</span></span><br><span class="line"><span class="comment">//             progressive: true, //类型：Boolean 默认：false 无损压缩jpg图片</span></span><br><span class="line"><span class="comment">//             interlaced: false, //类型：Boolean 默认：false 隔行扫描gif进行渲染</span></span><br><span class="line"><span class="comment">//             multipass: false, //类型：Boolean 默认：false 多次优化svg直到完全优化</span></span><br><span class="line"><span class="comment">//         &#125;))</span></span><br><span class="line"><span class="comment">//         .pipe(gulp.dest('./public/images'));</span></span><br><span class="line"><span class="comment">// &#125;);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 压缩 public/images 目录内图片(Version&gt;3)</span></span><br><span class="line">gulp.task(<span class="string">'minify-images'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">done</span>) </span>&#123;</span><br><span class="line">    gulp.src(<span class="string">'./public/images/**/*.*'</span>)</span><br><span class="line">        .pipe(imagemin([</span><br><span class="line">            imagemin.gifsicle(&#123;<span class="attr">interlaced</span>: <span class="literal">true</span>&#125;),</span><br><span class="line">            imagemin.jpegtran(&#123;<span class="attr">progressive</span>: <span class="literal">true</span>&#125;),</span><br><span class="line">            imagemin.optipng(&#123;<span class="attr">optimizationLevel</span>: <span class="number">5</span>&#125;),</span><br><span class="line">            imagemin.svgo(&#123;</span><br><span class="line">                plugins: [</span><br><span class="line">                    &#123;<span class="attr">removeViewBox</span>: <span class="literal">true</span>&#125;,</span><br><span class="line">                    &#123;<span class="attr">cleanupIDs</span>: <span class="literal">false</span>&#125;</span><br><span class="line">                ]</span><br><span class="line">            &#125;)</span><br><span class="line">        ]))</span><br><span class="line">        .pipe(gulp.dest(<span class="string">'./public/images'</span>));</span><br><span class="line">    done();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.0以前的写法 </span></span><br><span class="line"><span class="comment">//gulp.task('default', [</span></span><br><span class="line"><span class="comment">//  'minify-html', 'minify-css', 'minify-js', 'minify-images'</span></span><br><span class="line"><span class="comment">//]);</span></span><br><span class="line"><span class="comment">//4.0以后的写法</span></span><br><span class="line"><span class="comment">// 执行 gulp 命令时执行的任务</span></span><br><span class="line">gulp.task(<span class="string">'default'</span>, gulp.series(gulp.parallel(<span class="string">'minify-html'</span>, <span class="string">'minify-css'</span>, <span class="string">'minify-js'</span>, <span class="string">'minify-images'</span>)), <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"----------gulp Finished----------"</span>);</span><br><span class="line">    <span class="comment">// Do something after a, b, and c are finished.</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="4-创建-babelrc文件">4.创建<code>.babelrc</code>文件</h4><p>在 <code>Hexo</code> 站点目录下新建<code>.babelrc</code>文件，文件内容如下：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"presets"</span>: [<span class="string">"es2015"</span>],</span><br><span class="line">    <span class="attr">"plugins"</span>: [<span class="string">"transform-remove-strict-mode"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意:这里第一行我用双引号，<a href="https://www.jianshu.com/p/1123c89c491a" target="_blank" rel="noopener">原作者博客文章</a>里是单引号，因为在我的vs code编辑器里提示了语法错误</p><h4 id="5、静态资源压缩">5、静态资源压缩</h4><p>只需要每次在执行 <code>generate</code> 命令后执行 <code>gulp</code> 就可以实现对静态资源的压缩</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo g</span><br><span class="line">gulp</span><br></pre></td></tr></table></figure><p>到这里大家肯定觉得<code>ok</code>了,牛逼了💚,其实还没有结束😂</p><p>当我执行gulp命令后，</p><p><img src="3.png" alt=""></p><p>这是提示我有一个模块没有安装，找不到对应的依赖</p><p>那么我就安装呗</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install @babel&#x2F;core --save</span><br></pre></td></tr></table></figure><p>然后继续执行gulp命令，结果:</p><p><img src="2.png" alt=""></p><p>这里对应了标题也就是我自己遇到的问题，特地记录下来，问题描述就是说我们这个用到的<code>imagemin.jpegtran</code>不是一个函数，😭what???，这么坑的嘛，然后我就去找度娘，找到了对应的解决方案，<a href="https://stackoverflow.com/questions/60170048/how-to-solve-the-gulp-error-imagemin-jpegtran-is-not-a-function" target="_blank" rel="noopener">原文在这里</a>👈</p><p>大概意思就是我们用到的这个函数它不在我们安装的imagemin插件中，我们需要额外安装对应的插件，写到这里，我真觉得有点坑啊，于是我们安装对应插件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install --save-dev imagemin-mozjpeg</span><br></pre></td></tr></table></figure><p>然而没有卵用，我真服了啊😭我就想既然没用，我猜想那这个函数肯定没有在这个插件里，于是自己找到含有这个函数名的插件，抱着试试的心态继续折腾一下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install --save imagemin-jpegtran</span><br></pre></td></tr></table></figure><p>然后添加以下代码</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在文件开头添加以下代码</span></span><br><span class="line"><span class="keyword">const</span> imageminJpegtran = <span class="built_in">require</span>(<span class="string">'imagemin-jpegtran'</span>);</span><br><span class="line"><span class="comment">// imagemin.jpegtran(&#123;progressive: true&#125;),</span></span><br><span class="line"><span class="comment">//将上面对应代码替换为这句，注意句尾有逗号间隔</span></span><br><span class="line">&#123;<span class="attr">use</span>: [imageminJpegtran()]&#125;,</span><br></pre></td></tr></table></figure><p>然而最后还是没有成功报错如下:</p><p><img src="4.png" alt=""></p><p>后来我更改代码如下:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</span><br><span class="line"> <span class="keyword">var</span> minifycss = <span class="built_in">require</span>(<span class="string">'gulp-minify-css'</span>);</span><br><span class="line"> <span class="keyword">var</span> uglify = <span class="built_in">require</span>(<span class="string">'gulp-uglify'</span>);</span><br><span class="line"> <span class="keyword">var</span> htmlmin = <span class="built_in">require</span>(<span class="string">'gulp-htmlmin'</span>);</span><br><span class="line"> <span class="keyword">var</span> htmlclean = <span class="built_in">require</span>(<span class="string">'gulp-htmlclean'</span>);</span><br><span class="line"> <span class="keyword">var</span> imagemin = <span class="built_in">require</span>(<span class="string">'gulp-imagemin'</span>);</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 压缩css文件</span></span><br><span class="line"> gulp.task(<span class="string">'minify-css'</span>,<span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> gulp.src(<span class="string">'./public/**/*.css'</span>)</span><br><span class="line">     .pipe(minifycss())</span><br><span class="line">     .pipe(gulp.dest(<span class="string">'./public'</span>));</span><br><span class="line"> &#125;);</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 压缩html文件</span></span><br><span class="line"> gulp.task(<span class="string">'minify-html'</span>, <span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> gulp.src(<span class="string">'./public/**/*.html'</span>)</span><br><span class="line">     .pipe(htmlclean())</span><br><span class="line">     .pipe(htmlmin(&#123;</span><br><span class="line">       removeComments: <span class="literal">true</span>,</span><br><span class="line">       minifyJS: <span class="literal">true</span>,</span><br><span class="line">       minifyCSS: <span class="literal">true</span>,</span><br><span class="line">       minifyURLs: <span class="literal">true</span>,</span><br><span class="line">     &#125;))</span><br><span class="line">     .pipe(gulp.dest(<span class="string">'./public'</span>))</span><br><span class="line"> &#125;);</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 压缩js文件</span></span><br><span class="line"> gulp.task(<span class="string">'minify-js'</span>, <span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> gulp.src(<span class="string">'./public/**/*.js'</span>)</span><br><span class="line">     .pipe(uglify())</span><br><span class="line">     .pipe(gulp.dest(<span class="string">'./public'</span>));</span><br><span class="line"> &#125;);</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 压缩 public/images 目录内图片</span></span><br><span class="line"> gulp.task(<span class="string">'minify-images'</span>, <span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   gulp.src(<span class="string">'./public/images/**/*.*'</span>)</span><br><span class="line">     .pipe(imagemin(&#123;</span><br><span class="line">       optimizationLevel: <span class="number">5</span>, <span class="comment">//类型：Number  默认：3  取值范围：0-7（优化等级）</span></span><br><span class="line">       progressive: <span class="literal">true</span>, <span class="comment">//类型：Boolean 默认：false 无损压缩jpg图片</span></span><br><span class="line">       interlaced: <span class="literal">false</span>, <span class="comment">//类型：Boolean 默认：false 隔行扫描gif进行渲染</span></span><br><span class="line">       multipass: <span class="literal">false</span>, <span class="comment">//类型：Boolean 默认：false 多次优化svg直到完全优化</span></span><br><span class="line">     &#125;))</span><br><span class="line">     .pipe(gulp.dest(<span class="string">'./public/images'</span>));</span><br><span class="line"> &#125;);</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 默认任务</span></span><br><span class="line"> gulp.task(<span class="string">'default'</span>, gulp.series(gulp.parallel(<span class="string">'minify-html'</span>, <span class="string">'minify-css'</span>, <span class="string">'minify-js'</span>, <span class="string">'minify-images'</span>)), <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"----------gulp Finished----------"</span>);</span><br><span class="line">    <span class="comment">// Do something after a, b, and c are finished.</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>终于压缩成功但是不足的是压缩量没那么多，再想想其他办法😥</p><p><img src="5.png" alt=""></p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>Flex布局</title>
    <url>/posts/ab688311/</url>
    <content><![CDATA[<!-- build time:Mon Mar 09 2020 17:05:46 GMT+0800 (GMT+08:00) --><h2 id="center-移动web开发——flex布局-center"><center>移动web开发——flex布局</center></h2><a id="more"></a><h2 id="传统布局和flex布局对比">传统布局和flex布局对比</h2><h3 id="传统布局">传统布局</h3><ul><li>兼容性好</li><li>布局繁琐</li><li>局限性，不能再移动端很好的布局</li></ul><h3 id="flex布局">flex布局</h3><ul><li>操作方便，布局极其简单，移动端使用比较广泛</li><li>pc端浏览器支持情况比较差</li><li>IE11或更低版本不支持flex或仅支持部分</li></ul><h3 id="建议">建议</h3><ul><li>如果是pc端页面布局，还是采用传统方式</li><li>如果是移动端或者是不考虑兼容的pc则采用flex</li></ul><h2 id="flex布局原理">flex布局原理</h2><ul><li>flex 是 flexible Box 的缩写，意为&quot;弹性布局&quot;，用来为盒状模型提供最大的灵活性，任何一个容器都可以指定为 flex 布局。</li><li>当我们为父盒子设为 flex 布局以后，子元素的 float、clear 和 vertical-align 属性将失效。</li><li>flex布局又叫伸缩布局 、弹性布局 、伸缩盒布局 、弹性盒布局</li><li>采用 Flex 布局的元素，称为 Flex 容器（flex</li></ul><p>container），简称&quot;容器&quot;。它的所有子元素自动成为容器成员，称为 Flex 项目（flex<br>item），简称&quot;项目&quot;。</p><p><strong>总结</strong>：就是通过给父盒子添加flex属性，来控制子盒子的位置和排列方式</p><h2 id="父项常见属性">父项常见属性</h2><ul><li>flex-direction：设置主轴的方向</li><li>justify-content：设置主轴上的子元素排列方式</li><li>flex-wrap：设置子元素是否换行</li><li>align-content：设置侧轴上的子元素的排列方式（多行）</li><li>align-items：设置侧轴上的子元素排列方式（单行）</li><li>flex-flow：复合属性，相当于同时设置了 flex-direction 和 flex-wrap</li></ul><h3 id="flex-direction设置主轴的方向">flex-direction设置主轴的方向</h3><ul><li><p>在 flex 布局中，是分为主轴和侧轴两个方向，同样的叫法有 ： 行和列、x 轴和y 轴</p></li><li><p>默认主轴方向就是 x 轴方向，水平向右</p></li><li><p>默认侧轴方向就是 y 轴方向，水平向下</p><p><img src="1.JPG" alt=""></p></li><li><p>注意： 主轴和侧轴是会变化的，就看 flex-direction 设置谁为主轴，剩下的就是侧轴。而我们的子元素是跟着主轴来排列的</p><p><img src="2.JPG" alt=""></p></li></ul><h3 id="justify-content-设置主轴上的子元素排列方式">justify-content 设置主轴上的子元素排列方式</h3><p><img src="3.JPG" alt=""></p><h3 id="flex-wrap设置是否换行">flex-wrap设置是否换行</h3><ul><li>默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，flex布局中默认是不换行的。</li><li>nowrap 不换行</li><li>wrap 换行</li></ul><h3 id="align-items-设置侧轴上的子元素排列方式（单行-）">align-items 设置侧轴上的子元素排列方式（单行 ）</h3><ul><li>该属性是控制子项在侧轴（默认是y轴）上的排列方式 在子项为单项（单行）的时候使用</li><li>flex-start 从头部开始</li><li>flex-end 从尾部开始</li><li>center 居中显示</li><li>stretch 拉伸</li></ul><h3 id="align-content-设置侧轴上的子元素的排列方式（多行）">align-content 设置侧轴上的子元素的排列方式（多行）</h3><p>设置子项在侧轴上的排列方式 并且只能用于子项出现 换行 的情况（多行），在单行下是没有效果的。</p><p>​	<img src="4.JPG" alt=""></p><h3 id="align-content-和align-items区别">align-content 和align-items区别</h3><ul><li>align-items 适用于单行情况下， 只有上对齐、下对齐、居中和 拉伸</li><li>align-content适应于换行（多行）的情况下（单行情况下无效）， 可以设置 上对齐、下对齐、居中、拉伸以及平均分配剩余空间等属性值。</li><li>总结就是单行找align-items 多行找 align-content</li></ul><h3 id="flex-flow-属性是-flex-direction-和-flex-wrap-属性的复合属性">flex-flow 属性是 flex-direction 和 flex-wrap 属性的复合属性</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">flex-flow:row wrap;</span><br></pre></td></tr></table></figure><h2 id="flex布局子项常见属性">flex布局子项常见属性</h2><ul><li>flex子项目占的份数</li><li>align-self控制子项自己在侧轴的排列方式</li><li>order属性定义子项的排列顺序（前后顺序）</li></ul><h3 id="flex-属性">flex 属性</h3><p>flex 属性定义子项目分配剩余空间，用flex来表示占多少份数。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;    </span><br><span class="line">	<span class="attribute">flex</span>: &lt;number&gt;; <span class="comment">/* 默认值 0 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="align-self控制子项自己在侧轴上的排列方式">align-self控制子项自己在侧轴上的排列方式</h3><p>align-self 属性允许单个项目有与其他项目不一样的对齐方式，可覆盖 align-items 属性。</p><p>默认值为 auto，表示继承父元素的 align-items 属性，如果没有父元素，则等同于 stretch。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">span</span><span class="selector-pseudo">:nth-child(2)</span> &#123;      </span><br><span class="line">    <span class="comment">/* 设置自己在侧轴上的排列方式 */</span>      </span><br><span class="line">    <span class="attribute">align-self</span>: flex-end;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="order-属性定义项目的排列顺序">order 属性定义项目的排列顺序</h3><p>数值越小，排列越靠前，默认为0。</p><p>注意：和 z-index 不一样。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;    </span><br><span class="line">    <span class="attribute">order</span>: &lt;number&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>css居中的几种方式</title>
    <url>/posts/fc1b53fb/</url>
    <content><![CDATA[<!-- build time:Mon Mar 09 2020 17:05:46 GMT+0800 (GMT+08:00) --><h3 id="center-概述-前端面试经典问题CSS居中方式❤️-center"><center>概述: 前端面试经典问题CSS居中方式❤️</center></h3><a id="more"></a><h3 id="1-水平居中的-margin：0-auto😊">1.水平居中的 margin：0 auto😊</h3><p>这个是作用在子元素上，给父元素添加，父元素也会水平居中👍</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;<span class="selector-tag">style</span>&gt;</span><br><span class="line">	* &#123;</span><br><span class="line">		<span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">		<span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="selector-class">.box</span> &#123;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">        <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">        <span class="attribute">border</span>: <span class="number">3px</span> solid red;</span><br><span class="line">        <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="selector-tag">img</span> &#123;</span><br><span class="line">		<span class="attribute">display</span>: block;</span><br><span class="line">		<span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">		<span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">		<span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">	&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;<span class="selector-tag">body</span>&gt;</span><br><span class="line">	&lt;div class="box"&gt;</span><br><span class="line">		&lt;img src="../images/2.jpg" alt=""&gt;</span><br><span class="line">	&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><p>如图所示：</p><p><img src="2.png" alt="水平居中1"></p><h3 id="2-水平居中-text-align-center😊">2.水平居中 text-align: center😊</h3><p>img的<code>display:inline-block</code>; 不受float影响,实质是在父元素上添加效果让它进行水平居中👍</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;<span class="selector-tag">style</span>&gt;</span><br><span class="line">	* &#123;</span><br><span class="line">		<span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">		<span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="selector-class">.box</span> &#123;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">        <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">        <span class="attribute">border</span>: <span class="number">3px</span> solid red;</span><br><span class="line">        <span class="attribute">text-align</span>: center;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="selector-tag">img</span> &#123;</span><br><span class="line">		<span class="attribute">display</span>: inline-block;</span><br><span class="line">		<span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">		<span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">		<span class="comment">/*margin: 0 auto;*/</span></span><br><span class="line">	&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;<span class="selector-tag">body</span>&gt;</span><br><span class="line">	&lt;div class="box"&gt;</span><br><span class="line">		&lt;img src="../images/2.jpg" alt=""&gt;</span><br><span class="line">	&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><p>如图所示:</p><p><img src="2.png" alt="水平居中2"></p><h3 id="3-水平垂直居中-一-定位和定位元素的margin减去宽高的一半😊">3.水平垂直居中(一)定位和定位元素的margin减去宽高的一半😊</h3><p>这种方法局限性在于需要知道垂直居中的宽高才能实现👍</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;<span class="selector-tag">style</span>&gt;</span><br><span class="line">	* &#123;</span><br><span class="line">		<span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">		<span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="selector-class">.box</span> &#123;</span><br><span class="line">		<span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">		<span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">		<span class="attribute">background</span>: <span class="number">#e9df7c</span>;</span><br><span class="line">		<span class="attribute">border</span>: <span class="number">1px</span> solid skyblue;</span><br><span class="line">		<span class="attribute">position</span>: relative;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="selector-tag">img</span> &#123;</span><br><span class="line">		<span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">		<span class="attribute">height</span>: <span class="number">150px</span>;</span><br><span class="line">		<span class="attribute">position</span>: absolute;</span><br><span class="line">		<span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">		<span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">		<span class="attribute">margin-top</span>: -<span class="number">75px</span>;</span><br><span class="line">		<span class="attribute">margin-left</span>: -<span class="number">50px</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;<span class="selector-tag">body</span>&gt;</span><br><span class="line">	&lt;div class="box"&gt;</span><br><span class="line">		&lt;img src="../images/sun.jpg" alt=""&gt;</span><br><span class="line">	&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><p>如图所示:</p><p><img src="3.png" alt="水平垂直居中一"></p><h3 id="4-水平垂直居中-二-定位和margin-auto😊">4.水平垂直居中(二)定位和margin:auto😊</h3><p>这个方法很实用，不需要知道宽高，不受其限制👍</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;<span class="selector-tag">style</span>&gt;</span><br><span class="line">* &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#e9dfc7</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid skyblue;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">img</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">margin</span>: auto;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line">&lt;<span class="selector-tag">body</span>&gt;</span><br><span class="line">    &lt;div class="box"&gt;</span><br><span class="line">        &lt;img src="../img/01.png"&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><p>如图所示:</p><p><img src="1.png" alt="水平垂直居中二"></p><h3 id="5-水平垂直居中-三-绝对定位和transform😊">5.水平垂直居中(三)绝对定位和transform😊</h3><p>这个方法比较高级了，用到了形变，很多大佬喜欢使用这个方法进行定位，逼格很高的，学会后面试一定要用！这个是不需要知道居中元素的宽高就可以使用的，代码里的图片稍微有点大，改改宽高，仅此而已，在面试中大部分人会问如果不知道宽高该如何居中，答这个，加分！👍对transform不了解的同学可以查阅一下资料了解一下！</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line"> &lt;<span class="selector-tag">style</span>&gt;</span><br><span class="line">* &#123;</span><br><span class="line">	<span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">	<span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">	 <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">	 <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">	 <span class="attribute">background</span>: <span class="number">#e9dfc7</span>;</span><br><span class="line">	 <span class="attribute">border</span>: <span class="number">1px</span> solid pink;</span><br><span class="line">	 <span class="attribute">position</span>: relative;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="selector-tag">img</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>,-<span class="number">50%</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;<span class="selector-tag">body</span>&gt;</span><br><span class="line">	&lt;div class="box"&gt;</span><br><span class="line">		&lt;img src="../img/04.png"&gt;</span><br><span class="line">	&lt;/div&gt;	</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><p>如图所示:</p><p><img src="4.png" alt="水平垂直居中三"></p><h3 id="6-水平垂直居中-四-display-table-cell😊">6.水平垂直居中(四)display:table-cell😊</h3><p>其实就是把其变成表格样式，再按照表格的样式进行居中，很方便👍</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;<span class="selector-tag">style</span>&gt;</span><br><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">	<span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">	<span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">	<span class="attribute">background</span>: <span class="number">#e9dfc7</span>;</span><br><span class="line">	<span class="attribute">border</span>: <span class="number">1px</span> solid hotpink;</span><br><span class="line">	<span class="attribute">display</span>: table-cell;</span><br><span class="line">	<span class="attribute">vertical-align</span>: middle;</span><br><span class="line">	<span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">img</span> &#123;</span><br><span class="line">	<span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">	<span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;<span class="selector-tag">body</span>&gt;</span><br><span class="line">&lt;div class="box"&gt;</span><br><span class="line">&lt;img src="../img/05.png"alt=""&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><p>如图所示:</p><p><img src="5.png" alt="水平垂直居中四"></p><h3 id="7-水平垂直居中-五-flexBox居中😊">7.水平垂直居中(五)flexBox居中😊</h3><p>这个使用了CSS3的新特性flex，非常方便快捷，在移动端使用完美，pc端有兼容性问题，详细的flex知识点可以参考我的<a href="https://mcgaixuexi.github.io/2020/03/04/Flex%E5%B8%83%E5%B1%80/" target="_blank" rel="noopener">Flex布局</a>👈这篇文章💪</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;<span class="selector-tag">style</span>&gt;</span><br><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">	<span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">	<span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">	<span class="attribute">background</span>: <span class="number">#e9dfc7</span>;</span><br><span class="line">	<span class="attribute">border</span>: <span class="number">1px</span> solid hotpink;</span><br><span class="line">	<span class="attribute">display</span>: flex;</span><br><span class="line">	<span class="attribute">justify-content</span>: center;</span><br><span class="line">	<span class="attribute">align-items</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">img</span> &#123;</span><br><span class="line">	<span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">	<span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;<span class="selector-tag">body</span>&gt;</span><br><span class="line">&lt;div class="box"&gt;</span><br><span class="line">&lt;img src="../img/03.png"alt=""&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><p>如图所示:</p><p><img src="6.png" alt="水平垂直居中五"></p><h3 id="8-水平垂直居中-六-vertical-align-middle😊">8.水平垂直居中(六)vertical-align:middle😊</h3><p>这方法不常见，但是有位网友补充后还是可以的，这个方法关键要有一个和容器一样高的的元素作为居中的一个参照，就如b元素一样👍</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;<span class="selector-tag">style</span>&gt;</span><br><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">	<span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">	<span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">	<span class="attribute">background</span>: <span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, .<span class="number">5</span>);</span><br><span class="line">	<span class="attribute">text-align</span>: center;</span><br><span class="line">	<span class="attribute">font-size</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.cz</span> &#123;</span><br><span class="line">	<span class="attribute">display</span>: inline-flex;</span><br><span class="line">	<span class="attribute">width</span>: <span class="number">0px</span>;</span><br><span class="line">	<span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">	<span class="attribute">vertical-align</span>: middle;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">img</span> &#123;</span><br><span class="line">	<span class="attribute">display</span>: inline-block;</span><br><span class="line">	<span class="attribute">vertical-align</span>: middle;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;<span class="selector-tag">body</span>&gt;</span><br><span class="line">&lt;div class="box"&gt;</span><br><span class="line">&lt;b class="cz"&gt;&lt;/b&gt;</span><br><span class="line">&lt;img src="../img/06.png"alt=""&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><p>如图所示:</p><p><img src="7.png" alt="水平垂直居中六"></p><h4 id="文章就到这里，谢谢大家支持，请多多提意见😄参考这位网友的文章👈">文章就到这里，谢谢大家支持，请多多提意见😄<a href="https://www.jianshu.com/p/a7552ce07c88" target="_blank" rel="noopener">参考这位网友的文章</a>👈</h4><!-- rebuild by neat -->]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
</search>
